"use strict";
/*
 * Copyright 2020 - MATTR Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.blindSign = exports.verifyBlindSignContext = exports.commitmentForBlindSignRequest = exports.blsVerifyProof = exports.verifyProof = exports.blsCreateProof = exports.createProof = exports.blsVerify = exports.verify = exports.blsSign = exports.sign = exports.BBS_SIGNATURE_LENGTH = void 0;
var bls12381toBbs_1 = require("./bls12381toBbs");
/**
 * @ignore
 */
// eslint-disable-next-line @typescript-eslint/no-var-requires
var path = require("path");
// eslint-disable-next-line @typescript-eslint/no-var-requires
var bbs = require(path.resolve(path.join(__dirname, "../native/index.node")));
/**
 * Default BBS Signature Length
 */
exports.BBS_SIGNATURE_LENGTH = 112;
/**
 * Signs a set of messages with a BBS key pair and produces a BBS signature
 * @param request Request for the sign operation
 *
 * @returns The raw signature value
 */
exports.sign = function (request) {
    var _a;
    var keyPair = request.keyPair, messages = request.messages;
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        return new Uint8Array(bbs.bbs_sign({
            publicKey: keyPair.publicKey.buffer,
            secretKey: (_a = keyPair.secretKey) === null || _a === void 0 ? void 0 : _a.buffer,
            messages: messageBuffers,
        }));
    }
    catch (_b) {
        throw new Error("Failed to sign");
    }
};
/**
 * Signs a set of messages with a BLS 12-381 key pair and produces a BBS signature
 * @param request Request for the sign operation
 *
 * @returns The raw signature value
 */
exports.blsSign = function (request) {
    var _a;
    var keyPair = request.keyPair, messages = request.messages;
    var bbsKeyPair = bls12381toBbs_1.bls12381toBbs({ keyPair: keyPair, messageCount: messages.length });
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        return new Uint8Array(bbs.bbs_sign({
            publicKey: bbsKeyPair.publicKey.buffer,
            secretKey: (_a = bbsKeyPair.secretKey) === null || _a === void 0 ? void 0 : _a.buffer,
            messages: messageBuffers,
        }));
    }
    catch (_b) {
        throw new Error("Failed to sign");
    }
};
/**
 * Verifies a BBS+ signature for a set of messages with a BBS public key
 * @param request Request for the signature verification operation
 *
 * @returns A result indicating if the signature was verified
 */
exports.verify = function (request) {
    var publicKey = request.publicKey, signature = request.signature, messages = request.messages;
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        var result = bbs.bbs_verify({
            publicKey: publicKey.buffer,
            signature: signature.buffer,
            messages: messageBuffers,
        });
        return { verified: result };
    }
    catch (ex) {
        return { verified: false, error: ex };
    }
};
/**
 * Verifies a BBS+ signature for a set of messages with a with a BLS 12-381 public key
 * @param request Request for the signature verification operation
 *
 * @returns A result indicating if the signature was verified
 */
exports.blsVerify = function (request) {
    try {
        var publicKey = request.publicKey, signature = request.signature, messages = request.messages;
        var bbsKeyPair = bls12381toBbs_1.bls12381toBbs({ keyPair: { publicKey: publicKey }, messageCount: messages.length });
        var messageBuffers = messages.map(function (_) { return _.buffer; });
        var result = bbs.bbs_verify({
            publicKey: bbsKeyPair.publicKey.buffer,
            signature: signature.buffer,
            messages: messageBuffers,
        });
        return { verified: result };
    }
    catch (ex) {
        return { verified: false, error: ex };
    }
};
/**
 * Creates a BBS+ proof for a set of messages from a BBS public key and a BBS signature
 * @param request Request for the create proof operation
 *
 * @returns The raw proof value
 */
exports.createProof = function (request) {
    var publicKey = request.publicKey, signature = request.signature, messages = request.messages, nonce = request.nonce, revealed = request.revealed;
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        return new Uint8Array(bbs.bbs_create_proof({
            nonce: nonce.buffer,
            revealed: revealed,
            publicKey: publicKey.buffer,
            signature: signature.buffer,
            messages: messageBuffers,
        }));
    }
    catch (ex) {
        throw new Error("Failed to create proof");
    }
};
/**
 * Creates a BBS+ proof for a set of messages from a BLS12-381 public key and a BBS signature
 * @param request Request for the create proof operation
 *
 * @returns The raw proof value
 */
exports.blsCreateProof = function (request) {
    var publicKey = request.publicKey, signature = request.signature, messages = request.messages, nonce = request.nonce, revealed = request.revealed;
    var bbsKeyPair = bls12381toBbs_1.bls12381toBbs({ keyPair: { publicKey: publicKey }, messageCount: messages.length });
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        return new Uint8Array(bbs.bbs_create_proof({
            nonce: nonce.buffer,
            revealed: revealed,
            publicKey: bbsKeyPair.publicKey.buffer,
            signature: signature.buffer,
            messages: messageBuffers,
        }));
    }
    catch (ex) {
        throw new Error("Failed to create proof");
    }
};
/**
 * Verifies a BBS+ proof with a BBS public key
 * @param request Request for the verify proof operation
 *
 * @returns A result indicating if the proof was verified
 */
exports.verifyProof = function (request) {
    var publicKey = request.publicKey, proof = request.proof, messages = request.messages, nonce = request.nonce;
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        var result = bbs.bbs_verify_proof({
            nonce: nonce.buffer,
            publicKey: publicKey.buffer,
            proof: proof.buffer,
            messages: messageBuffers,
        });
        return { verified: result };
    }
    catch (ex) {
        return { verified: false, error: ex };
    }
};
/**
 * Verifies a BBS+ proof with a BLS12-381 public key
 * @param request Request for the verify proof operation
 *
 * @returns A result indicating if the proof was verified
 */
exports.blsVerifyProof = function (request) {
    try {
        var publicKey = request.publicKey, proof = request.proof, messages = request.messages, nonce = request.nonce;
        var messageBuffers = messages.map(function (_) { return _.buffer; });
        var result = bbs.bls_verify_proof({
            nonce: nonce.buffer,
            publicKey: publicKey.buffer,
            proof: proof.buffer,
            messages: messageBuffers,
        });
        return { verified: result };
    }
    catch (ex) {
        return { verified: false, error: ex };
    }
};
/**
 * Create a blinded commitment of messages for use in producing a blinded BBS+ signature
 * @param request Request for producing the blinded commitment
 *
 * @returns A commitment context
 */
exports.commitmentForBlindSignRequest = function (request) {
    var publicKey = request.publicKey, messages = request.messages, hidden = request.hidden, nonce = request.nonce;
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        return bbs.bbs_blind_signature_commitment({
            publicKey: publicKey.buffer,
            messages: messageBuffers,
            hidden: hidden,
            nonce: nonce,
        });
    }
    catch (_a) {
        throw new Error("Failed to generate commitment");
    }
};
/**
 * Verifies a blind commitment of messages
 * @param request Request for the commitment verification
 *
 * @returns A boolean indicating if the context was verified
 */
exports.verifyBlindSignContext = function (request) {
    var commitment = request.commitment, proofOfHiddenMessages = request.proofOfHiddenMessages, challengeHash = request.challengeHash, publicKey = request.publicKey, blinded = request.blinded, nonce = request.nonce;
    return bbs.bbs_verify_blind_signature_proof({
        commitment: commitment.buffer,
        proofOfHiddenMessages: proofOfHiddenMessages.buffer,
        challengeHash: challengeHash.buffer,
        publicKey: publicKey.buffer,
        blinded: blinded,
        nonce: nonce,
    });
};
/**
 * Signs a set of messages featuring both known and blinded messages to the signer and produces a BBS+ signature
 * @param request Request for the blind sign operation
 *
 * @returns The raw signature value
 */
exports.blindSign = function (request) {
    var commitment = request.commitment, secretKey = request.secretKey, messages = request.messages;
    var messageBuffers = messages.map(function (_) { return _.buffer; });
    try {
        return new Uint8Array(bbs.bbs_blind_sign({
            commitment: commitment.buffer,
            secretKey: secretKey.buffer,
            messages: messageBuffers,
        }));
    }
    catch (ex) {
        throw new Error("Failed to sign");
    }
};
//# sourceMappingURL=bbsSignature.js.map