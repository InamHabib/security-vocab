{"version":3,"file":"did-key-web-crypto.cjs.production.min.js","sources":["../src/constants/index.ts","../src/crypto.ts","../src/functions/jwkToBase58.ts","../src/functions/fingerprintToDid.ts","../src/functions/fromJwk.ts","../src/functions/getMultibaseFromJwk.ts","../src/Jwe/Jwe.ts","../src/Jws/Jws.ts","../src/functions/base58KeyPairToJwk.ts","../src/functions/getJwkTypeFromMultibase.ts","../src/functions/toJwkPair.ts","../src/KeyPair.ts","../src/functions/generate.ts","../src/driver.ts"],"sourcesContent":["// See https://github.com/multiformats/multicodec/pull/190\n\nexport const SUPPORTED_EC = [\n  'P-256',\n  'P-384',\n  'P-521',\n  // not currently supported by web crypto\n  // 'Ed448', 'X448'\n];\n\nexport const multicodecPrefix = 0x12;\n\nexport const crvToMulticodecPrefix: any = {\n  'P-256': 0x00,\n  'P-384': 0x01,\n  'P-521': 0x02,\n  // Ed448: 0x03,\n  // X448: 0x04,\n};\n\nexport const multicodecToJwkType: any = {\n  0x00: { kty: 'EC', crv: 'P-256' },\n  0x01: { kty: 'EC', crv: 'P-384' },\n  0x02: { kty: 'EC', crv: 'P-521' },\n  // 0x03: { kty: 'OKP', crv: 'Ed448' },\n  // 0x04: { kty: 'OKP', crv: 'X448' },\n};\n\nexport const crvToJwsAlg: any = {\n  'P-256': 'ES256',\n  'P-384': 'ES384',\n  'P-521': 'ES521',\n};\n\nexport const crvToJwsHashAlg: any = {\n  'P-256': 'SHA-256',\n  'P-384': 'SHA-384',\n  'P-521': 'SHA-512',\n};\n","import { Crypto } from '@peculiar/webcrypto';\n\nfunction isNodejs() {\n  return (\n    typeof process === 'object' &&\n    typeof process.versions === 'object' &&\n    typeof process.versions.node !== 'undefined' &&\n    typeof window !== undefined\n  );\n}\n\nlet crypto: Crypto;\n\nif (isNodejs()) {\n  crypto = new Crypto();\n} else {\n  crypto = window.crypto as Crypto;\n}\n\nexport default crypto;\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { types } from '@transmute/did-key-common';\n\nexport const jwkToBase58 = (jwk: any): types.LinkedDataKeyPair => {\n  let keypair: any = {};\n  if (jwk.d) {\n    keypair.privateKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.d)])\n    );\n  }\n  if (jwk.x) {\n    keypair.publicKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.x)])\n    );\n  }\n  if (jwk.x && jwk.y) {\n    keypair.publicKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.x), base64url.toBuffer(jwk.y)])\n    );\n  }\n\n  return keypair;\n};\n","export const fingerprintToDid = (fingerprint: string, methodName = 'key') => {\n  return `did:${methodName}:${fingerprint}`;\n};\n","import { types } from '@transmute/did-key-common';\n\nimport { jwkToBase58 } from './jwkToBase58';\nimport { getMultibaseFromJwk } from './getMultibaseFromJwk';\nimport { fingerprintToDid } from './fingerprintToDid';\n\nexport const fromJwk = (jwk: any): types.LinkedDataKeyPair => {\n  const id = getMultibaseFromJwk(jwk);\n  const controller = fingerprintToDid(id);\n  return {\n    id: `#${id}`,\n    type: 'JsonWebKey2020',\n    controller,\n    ...(jwkToBase58(jwk) as any),\n  };\n};\n","import bs58 from 'bs58';\n\nimport { crvToMulticodecPrefix } from '../constants';\nimport { jwkToBase58 } from './jwkToBase58';\n\nexport const getMultibaseFromJwk = (publicKeyJwk: any): string => {\n  const { publicKeyBase58 } = jwkToBase58(publicKeyJwk);\n  const publicKeyBytes = bs58.decode(publicKeyBase58);\n  const prefix = crvToMulticodecPrefix[publicKeyJwk.crv];\n  const buffer = new Uint8Array(3 + publicKeyBytes.length);\n  // https://github.com/multiformats/multicodec/pull/190\n  buffer[0] = 0x12;\n  buffer[1] = prefix;\n  buffer[2] = 0x01;\n  buffer.set(publicKeyBytes, 3);\n  // prefix with `z` to indicate multi-base base58btc encoding\n  return `z${bs58.encode(buffer)}`;\n};\n","import crypto from '../crypto';\n\nexport const deriveSecret = async (\n  privateKeyJwk: any,\n  publicKeyJwk: any\n): Promise<Uint8Array> => {\n  // console.log(privateKeyJwk, publicKeyJwk);\n  const privateKey = await crypto.subtle.importKey(\n    'jwk',\n    privateKeyJwk,\n    {\n      name: 'ECDH',\n      namedCurve: privateKeyJwk.crv,\n    },\n    true,\n    ['deriveBits']\n  );\n  const publicKey = await crypto.subtle.importKey(\n    'jwk',\n    publicKeyJwk,\n    {\n      name: 'ECDH',\n      namedCurve: publicKeyJwk.crv,\n    },\n    true,\n    ['deriveBits']\n  );\n  const result = await crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKey,\n    },\n    privateKey,\n    256\n  );\n  return new Uint8Array(result);\n};\n","import crypto from '../crypto';\nimport { Jws } from '@transmute/did-key-common';\n\nimport { crvToJwsHashAlg } from '../constants';\n\nconst { createJws, verifyJws, createDetachedJws, verifyDetachedJws } = Jws;\n\nexport { createJws, verifyJws, createDetachedJws, verifyDetachedJws };\n\nexport const privateKeyToSigner = async (privateKeyJwk: any) => {\n  const privateKey = await crypto.subtle.importKey(\n    'jwk',\n    privateKeyJwk,\n    {\n      name: 'ECDSA',\n      namedCurve: privateKeyJwk.crv,\n    },\n    true,\n    ['sign']\n  );\n\n  return {\n    sign: async (data: Buffer) => {\n      const signature = await crypto.subtle.sign(\n        {\n          name: 'ECDSA',\n          hash: { name: crvToJwsHashAlg[privateKeyJwk.crv] },\n        },\n        privateKey,\n        data\n      );\n      return signature as Buffer;\n    },\n  };\n};\n\nexport const publicKeyToVerifier = async (publicKeyJwk: any) => {\n  const publicKey = await crypto.subtle.importKey(\n    'jwk',\n    publicKeyJwk,\n    {\n      name: 'ECDSA',\n      namedCurve: publicKeyJwk.crv,\n    },\n    true,\n    ['verify']\n  );\n\n  return {\n    verify: async (toBeVerified: Buffer, signature: Buffer) => {\n      const verified = await crypto.subtle.verify(\n        {\n          name: 'ECDSA',\n          hash: { name: crvToJwsHashAlg[publicKeyJwk.crv] },\n        },\n        publicKey,\n        signature,\n        toBeVerified\n      );\n      return verified;\n    },\n  };\n};\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { types } from '@transmute/did-key-common';\n\nexport const base58KeyPairToJwk = (\n  keypair: types.LinkedDataKeyPair\n): object => {\n  const publicKeyBuffer = bs58.decode(keypair.publicKeyBase58);\n\n  const x = base64url.encode(\n    publicKeyBuffer.slice(0, publicKeyBuffer.length / 2)\n  );\n\n  const y = base64url.encode(publicKeyBuffer.slice(publicKeyBuffer.length / 2));\n\n  let jwk: any = { x, y };\n\n  if (keypair.privateKeyBase58) {\n    jwk.d = base64url.encode(bs58.decode(keypair.privateKeyBase58));\n  }\n\n  return jwk;\n};\n","import bs58 from 'bs58';\nimport { multicodecToJwkType } from '../constants';\nexport const getJwkTypeFromMultibase = (fingerprint: string) => {\n  const buffer = bs58.decode(fingerprint.substring(1));\n\n  if (buffer[0] !== 0x12) {\n    throw new Error(`Unsupported multibase ${buffer[0].toString(16)}`);\n  }\n\n  const type = multicodecToJwkType[buffer[1]];\n  if (!type) {\n    throw new Error(\n      `Unsupported multibase ${buffer[0].toString(16)} ${buffer[1].toString(\n        16\n      )}`\n    );\n  }\n  return type;\n};\n","import { types } from '@transmute/did-key-common';\n\nimport { base58KeyPairToJwk } from './base58KeyPairToJwk';\nimport { getJwkTypeFromMultibase } from './getJwkTypeFromMultibase';\nexport const toJwkPair = (\n  keypair: types.LinkedDataKeyPair\n): types.JsonWebKeyPair => {\n  // console.log('toJwkPair', keypair);\n  const id = keypair.id.substring(keypair.id.indexOf('#') + 1);\n  let _keypair: any = {\n    id: keypair.id,\n    type: 'JsonWebKey2020',\n    controller: keypair.controller,\n  };\n\n  _keypair.publicKeyJwk = {\n    ...getJwkTypeFromMultibase(id),\n    ...base58KeyPairToJwk({\n      publicKeyBase58: keypair.publicKeyBase58,\n    } as any),\n  };\n\n  if (keypair.privateKeyBase58) {\n    _keypair.privateKeyJwk = {\n      ...getJwkTypeFromMultibase(id),\n      ...base58KeyPairToJwk({\n        publicKeyBase58: keypair.publicKeyBase58,\n        privateKeyBase58: keypair.privateKeyBase58,\n      } as any),\n    };\n  }\n\n  return _keypair;\n};\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { generate } from './functions/generate';\nimport { fromJwk } from './functions/fromJwk';\n\nimport { deriveSecret } from './Jwe';\nimport { privateKeyToSigner, publicKeyToVerifier } from './Jws';\nimport { toJwkPair } from './functions/toJwkPair';\nimport { fingerprintToDid } from './functions/fingerprintToDid';\nimport { getJwkTypeFromMultibase } from './functions/getJwkTypeFromMultibase';\n\nimport { types } from '@transmute/did-key-common';\n\nimport {\n  getEpkGenerator,\n  deriveKey,\n  KeyEncryptionKey,\n} from '@transmute/did-key-cipher';\n\n/* class decorator */\nfunction staticImplements<T>() {\n  return <U extends T>(constructor: U) => {\n    return constructor;\n  };\n}\n\nconst KEY_TYPE = 'JsonWebKey2020';\n\n@staticImplements<types.KeyAgreementKeyPairClass>()\nexport class KeyPair implements types.KeyAgreementKeyPairInstance {\n  public static JWE_ALG: types.ECDH_ES_A256KW = 'ECDH-ES+A256KW';\n\n  static generate = async (options?: any) => {\n    const { privateKeyJwk } = await generate(options);\n    return new KeyPair({ ...fromJwk(privateKeyJwk) });\n  };\n\n  static from = (options?: any) => {\n    return new KeyPair({ ...options });\n  };\n\n  static fromFingerprint = async ({ fingerprint }: any) => {\n    const data = getJwkTypeFromMultibase(fingerprint);\n    if (data.kty) {\n      const publicKeyBytes = bs58.decode(fingerprint.substring(1));\n\n      const publicKeyBase58 = bs58.encode(publicKeyBytes.slice(3));\n\n      return new KeyPair({\n        id: '#' + fingerprint,\n        controller: fingerprintToDid(fingerprint),\n        type: 'JsonWebKey2020',\n        publicKeyBase58,\n      });\n    }\n    throw new Error('Cannot create key from fingerprint ' + fingerprint);\n  };\n\n  static fingerprintFromPublicKey(\n    keypair: types.KeyPairJwk | types.KeyPairBase58\n  ) {\n    let kp = KeyPair.from(keypair);\n    return kp.id.substring(1);\n  }\n\n  static async generateEphemeralKeyPair(\n    epkArgs: any\n  ): Promise<types.EpkResult> {\n    return getEpkGenerator(KeyPair, epkArgs)();\n  }\n\n  static async kekFromEphemeralPeer({\n    keyAgreementKey,\n    epk,\n  }: types.KeyEncryptionKeyFromEphemeralPublicKeyOptions) {\n    if (!(epk && typeof epk === 'object')) {\n      throw new TypeError('\"epk\" must be an object.');\n    }\n\n    // convert to LD key for Web KMS\n    const ephemeralPublicKey = new KeyPair({\n      publicKeyJwk: epk,\n    } as any);\n\n    // safe to use IDs like in rfc7518 or does\n    // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?\n\n    // \"Party U Info\"\n    const producerInfo = ephemeralPublicKey.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(keyAgreementKey.id);\n    // converts keys again....\n    // base58 encoding should only be used at the network / serialization boundary.\n    const secret = await (keyAgreementKey as types.KeyAgreementKeyPairInstance).deriveSecret(\n      {\n        publicKey: ephemeralPublicKey.toJsonWebKeyPair(),\n      } as any\n    );\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n    };\n  }\n\n  static async kekFromStaticPeer({\n    ephemeralKeyPair,\n    staticPublicKey,\n  }: types.KeyEncryptionKeyFromStaticPublicKeyOptions) {\n    if (staticPublicKey.type !== KEY_TYPE) {\n      throw new Error(`\"staticPublicKey.type\" must be \"${KEY_TYPE}\".`);\n    }\n\n    const epkPair = await KeyPair.from(ephemeralKeyPair.keypair);\n\n    // \"Party U Info\"\n    const producerInfo = epkPair.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(staticPublicKey.id);\n\n    const secret = await epkPair.deriveSecret({\n      publicKey: staticPublicKey,\n    } as any);\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n      epk: ephemeralKeyPair.epk,\n      apu: base64url.encode(producerInfo),\n      apv: base64url.encode(consumerInfo as any),\n    };\n  }\n\n  public id: string;\n  public type: string;\n  public controller: string;\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  constructor(options: any) {\n    this.id = options.id;\n    this.type = options.type || 'JsonWebKey2020';\n\n    this.controller = options.controller;\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      const args = fromJwk(options.publicKeyJwk);\n      this.publicKeyBuffer = bs58.decode(args.publicKeyBase58);\n      this.id = options.id || args.id;\n      this.controller = args.controller;\n    } else {\n      throw new Error('publicKeyJwk or publicKeyBase58 is required.');\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    } else if (options.privateKeyJwk) {\n      const { privateKeyBase58 } = fromJwk(options.privateKeyJwk);\n      this.privateKeyBuffer = bs58.decode(privateKeyBase58);\n    }\n  }\n\n  fingerprint() {\n    const { id } = this.toJsonWebKeyPair();\n    return id.substring(1);\n  }\n\n  toKeyPair(exportPrivateKey = false) {\n    let options: any = {\n      id: this.id,\n      type: 'UnsupportedVerificationMethod2020',\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (exportPrivateKey) {\n      options.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return options;\n  }\n\n  toJsonWebKeyPair(exportPrivateKey = false) {\n    const options = this.toKeyPair(exportPrivateKey);\n    return toJwkPair(options);\n  }\n\n  async signer() {\n    const { privateKeyJwk } = this.toJsonWebKeyPair(true);\n    return privateKeyToSigner(privateKeyJwk);\n  }\n\n  async verifier() {\n    const { publicKeyJwk } = this.toJsonWebKeyPair();\n    return publicKeyToVerifier(publicKeyJwk);\n  }\n\n  deriveSecret(options: types.DeriveSecretOptions) {\n    const { privateKeyJwk } = this.toJsonWebKeyPair(true);\n    let publicKeyJwk;\n\n    if ((options.publicKey as any).publicKeyJwk) {\n      publicKeyJwk = (options.publicKey as any).publicKeyJwk;\n    } else if ((options.publicKey as any).publicKeyBase58) {\n      ({ publicKeyJwk } = toJwkPair(options.publicKey as any));\n    } else {\n      throw new Error(\n        'Cannot deriveSecret from remote... publicKeyJwk or publicKeyBase58 must be present.'\n      );\n    }\n    return deriveSecret(privateKeyJwk, publicKeyJwk);\n  }\n}\n","import { SUPPORTED_EC } from '../constants';\nimport crypto from '../crypto';\n\nexport interface GenerateOptions {\n  kty: string;\n  crvOrSize: string;\n}\n\nexport const generate = async (\n  options: GenerateOptions = { kty: 'EC', crvOrSize: 'P-256' }\n) => {\n  if (options.kty === 'EC' && SUPPORTED_EC.indexOf(options.crvOrSize) !== -1) {\n    let kp = await crypto.subtle.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: options.crvOrSize,\n      },\n      true,\n      ['sign', 'verify']\n    );\n    const jwk = await crypto.subtle.exportKey('jwk', kp.privateKey);\n    return {\n      publicKeyJwk: {\n        kty: jwk.kty,\n        crv: jwk.crv,\n        x: jwk.x,\n        y: jwk.y,\n      },\n      privateKeyJwk: {\n        kty: jwk.kty,\n        crv: jwk.crv,\n        x: jwk.x,\n        y: jwk.y,\n        d: jwk.d,\n      },\n    };\n  }\n\n  throw new Error(\n    `Generate does not support ${options.kty} and ${options.crvOrSize}`\n  );\n};\n","import { getResolve, getGet } from '@transmute/did-key-common';\n\nimport { KeyPair } from './KeyPair';\n\nexport const resolve = getResolve(KeyPair);\nexport const get = getGet(resolve);\n"],"names":["SUPPORTED_EC","crvToMulticodecPrefix","multicodecToJwkType","kty","crv","crvToJwsHashAlg","process","versions","node","undefined","window","Crypto","crypto","jwkToBase58","jwk","keypair","d","privateKeyBase58","bs58","encode","Buffer","concat","base64url","toBuffer","x","publicKeyBase58","y","fingerprintToDid","fingerprint","methodName","fromJwk","publicKeyJwk","publicKeyBytes","prefix","buffer","id","decode","Uint8Array","length","set","type","controller","deriveSecret","privateKeyJwk","subtle","importKey","name","namedCurve","privateKey","publicKey","deriveBits","result","createJws","Jws","verifyJws","createDetachedJws","privateKeyToSigner","sign","data","hash","publicKeyToVerifier","verify","toBeVerified","signature","base58KeyPairToJwk","publicKeyBuffer","slice","getJwkTypeFromMultibase","substring","Error","toString","toJwkPair","indexOf","_keypair","staticImplements","constructor","KeyPair","options","args","privateKeyBuffer","fingerprintFromPublicKey","KeyPair_1","from","generateEphemeralKeyPair","epkArgs","getEpkGenerator","kekFromEphemeralPeer","keyAgreementKey","epk","TypeError","ephemeralPublicKey","producerInfo","consumerInfo","toJsonWebKeyPair","secret","deriveKey","keyData","KeyEncryptionKey","createKek","kek","kekFromStaticPeer","ephemeralKeyPair","staticPublicKey","epkPair","apu","apv","this","toKeyPair","exportPrivateKey","signer","verifier","crvOrSize","generateKey","kp","exportKey","generate","resolve","getResolve","getGet"],"mappings":"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"}