import { Jws, getResolve, getGet } from '@transmute/did-key-common';
import { __decorate } from 'tslib';
import bs58 from 'bs58';
import base64url from 'base64url';
import { Crypto } from '@peculiar/webcrypto';
import { getEpkGenerator, deriveKey, KeyEncryptionKey } from '@transmute/did-key-cipher';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// See https://github.com/multiformats/multicodec/pull/190
var SUPPORTED_EC = ['P-256', 'P-384', 'P-521'];
var crvToMulticodecPrefix = {
  'P-256': 0x00,
  'P-384': 0x01,
  'P-521': 0x02
};
var multicodecToJwkType = {
  0x00: {
    kty: 'EC',
    crv: 'P-256'
  },
  0x01: {
    kty: 'EC',
    crv: 'P-384'
  },
  0x02: {
    kty: 'EC',
    crv: 'P-521'
  }
};
var crvToJwsHashAlg = {
  'P-256': 'SHA-256',
  'P-384': 'SHA-384',
  'P-521': 'SHA-512'
};

function isNodejs() {
  return typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node !== 'undefined' && typeof window !== undefined;
}

var crypto;

if (isNodejs()) {
  crypto = /*#__PURE__*/new Crypto();
} else {
  crypto = window.crypto;
}

var crypto$1 = crypto;

var generate = function generate(options) {
  if (options === void 0) {
    options = {
      kty: 'EC',
      crvOrSize: 'P-256'
    };
  }

  try {
    var _temp3 = function _temp3(_result) {
      if (_exit2) return _result;
      throw new Error("Generate does not support " + options.kty + " and " + options.crvOrSize);
    };

    var _exit2 = false;

    var _temp4 = function () {
      if (options.kty === 'EC' && SUPPORTED_EC.indexOf(options.crvOrSize) !== -1) {
        return Promise.resolve(crypto$1.subtle.generateKey({
          name: 'ECDSA',
          namedCurve: options.crvOrSize
        }, true, ['sign', 'verify'])).then(function (kp) {
          return Promise.resolve(crypto$1.subtle.exportKey('jwk', kp.privateKey)).then(function (jwk) {
            _exit2 = true;
            return {
              publicKeyJwk: {
                kty: jwk.kty,
                crv: jwk.crv,
                x: jwk.x,
                y: jwk.y
              },
              privateKeyJwk: {
                kty: jwk.kty,
                crv: jwk.crv,
                x: jwk.x,
                y: jwk.y,
                d: jwk.d
              }
            };
          });
        });
      }
    }();

    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
  } catch (e) {
    return Promise.reject(e);
  }
};

var jwkToBase58 = function jwkToBase58(jwk) {
  var keypair = {};

  if (jwk.d) {
    keypair.privateKeyBase58 = bs58.encode(Buffer.concat([base64url.toBuffer(jwk.d)]));
  }

  if (jwk.x) {
    keypair.publicKeyBase58 = bs58.encode(Buffer.concat([base64url.toBuffer(jwk.x)]));
  }

  if (jwk.x && jwk.y) {
    keypair.publicKeyBase58 = bs58.encode(Buffer.concat([base64url.toBuffer(jwk.x), base64url.toBuffer(jwk.y)]));
  }

  return keypair;
};

var getMultibaseFromJwk = function getMultibaseFromJwk(publicKeyJwk) {
  var _jwkToBase = jwkToBase58(publicKeyJwk),
      publicKeyBase58 = _jwkToBase.publicKeyBase58;

  var publicKeyBytes = bs58.decode(publicKeyBase58);
  var prefix = crvToMulticodecPrefix[publicKeyJwk.crv];
  var buffer = new Uint8Array(3 + publicKeyBytes.length); // https://github.com/multiformats/multicodec/pull/190

  buffer[0] = 0x12;
  buffer[1] = prefix;
  buffer[2] = 0x01;
  buffer.set(publicKeyBytes, 3); // prefix with `z` to indicate multi-base base58btc encoding

  return "z" + bs58.encode(buffer);
};

var fingerprintToDid = function fingerprintToDid(fingerprint, methodName) {
  if (methodName === void 0) {
    methodName = 'key';
  }

  return "did:" + methodName + ":" + fingerprint;
};

var fromJwk = function fromJwk(jwk) {
  var id = getMultibaseFromJwk(jwk);
  var controller = fingerprintToDid(id);
  return _extends({
    id: "#" + id,
    type: 'JsonWebKey2020',
    controller: controller
  }, jwkToBase58(jwk));
};

var deriveSecret = function deriveSecret(privateKeyJwk, publicKeyJwk) {
  try {
    // console.log(privateKeyJwk, publicKeyJwk);
    return Promise.resolve(crypto$1.subtle.importKey('jwk', privateKeyJwk, {
      name: 'ECDH',
      namedCurve: privateKeyJwk.crv
    }, true, ['deriveBits'])).then(function (privateKey) {
      return Promise.resolve(crypto$1.subtle.importKey('jwk', publicKeyJwk, {
        name: 'ECDH',
        namedCurve: publicKeyJwk.crv
      }, true, ['deriveBits'])).then(function (publicKey) {
        return Promise.resolve(crypto$1.subtle.deriveBits({
          name: 'ECDH',
          "public": publicKey
        }, privateKey, 256)).then(function (result) {
          return new Uint8Array(result);
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createJws = Jws.createJws,
    createDetachedJws = Jws.createDetachedJws;
var privateKeyToSigner = function privateKeyToSigner(privateKeyJwk) {
  try {
    return Promise.resolve(crypto$1.subtle.importKey('jwk', privateKeyJwk, {
      name: 'ECDSA',
      namedCurve: privateKeyJwk.crv
    }, true, ['sign'])).then(function (privateKey) {
      return {
        sign: function (data) {
          try {
            return Promise.resolve(crypto$1.subtle.sign({
              name: 'ECDSA',
              hash: {
                name: crvToJwsHashAlg[privateKeyJwk.crv]
              }
            }, privateKey, data));
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var publicKeyToVerifier = function publicKeyToVerifier(publicKeyJwk) {
  try {
    return Promise.resolve(crypto$1.subtle.importKey('jwk', publicKeyJwk, {
      name: 'ECDSA',
      namedCurve: publicKeyJwk.crv
    }, true, ['verify'])).then(function (publicKey) {
      return {
        verify: function (toBeVerified, signature) {
          try {
            return Promise.resolve(crypto$1.subtle.verify({
              name: 'ECDSA',
              hash: {
                name: crvToJwsHashAlg[publicKeyJwk.crv]
              }
            }, publicKey, signature, toBeVerified));
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var base58KeyPairToJwk = function base58KeyPairToJwk(keypair) {
  var publicKeyBuffer = bs58.decode(keypair.publicKeyBase58);
  var x = base64url.encode(publicKeyBuffer.slice(0, publicKeyBuffer.length / 2));
  var y = base64url.encode(publicKeyBuffer.slice(publicKeyBuffer.length / 2));
  var jwk = {
    x: x,
    y: y
  };

  if (keypair.privateKeyBase58) {
    jwk.d = base64url.encode(bs58.decode(keypair.privateKeyBase58));
  }

  return jwk;
};

var getJwkTypeFromMultibase = function getJwkTypeFromMultibase(fingerprint) {
  var buffer = bs58.decode(fingerprint.substring(1));

  if (buffer[0] !== 0x12) {
    throw new Error("Unsupported multibase " + buffer[0].toString(16));
  }

  var type = multicodecToJwkType[buffer[1]];

  if (!type) {
    throw new Error("Unsupported multibase " + buffer[0].toString(16) + " " + buffer[1].toString(16));
  }

  return type;
};

var toJwkPair = function toJwkPair(keypair) {
  // console.log('toJwkPair', keypair);
  var id = keypair.id.substring(keypair.id.indexOf('#') + 1);
  var _keypair = {
    id: keypair.id,
    type: 'JsonWebKey2020',
    controller: keypair.controller
  };
  _keypair.publicKeyJwk = _extends({}, getJwkTypeFromMultibase(id), base58KeyPairToJwk({
    publicKeyBase58: keypair.publicKeyBase58
  }));

  if (keypair.privateKeyBase58) {
    _keypair.privateKeyJwk = _extends({}, getJwkTypeFromMultibase(id), base58KeyPairToJwk({
      publicKeyBase58: keypair.publicKeyBase58,
      privateKeyBase58: keypair.privateKeyBase58
    }));
  }

  return _keypair;
};

var KeyPair_1;
/* class decorator */

function staticImplements() {
  return function (constructor) {
    return constructor;
  };
}

var KEY_TYPE = 'JsonWebKey2020';

var KeyPair = KeyPair_1 = /*#__PURE__*/function () {
  function KeyPair(options) {
    this.id = options.id;
    this.type = options.type || 'JsonWebKey2020';
    this.controller = options.controller;

    if (options.publicKeyBase58) {
      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);
    } else if (options.publicKeyJwk) {
      var args = fromJwk(options.publicKeyJwk);
      this.publicKeyBuffer = bs58.decode(args.publicKeyBase58);
      this.id = options.id || args.id;
      this.controller = args.controller;
    } else {
      throw new Error('publicKeyJwk or publicKeyBase58 is required.');
    }

    if (options.privateKeyBase58) {
      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);
    } else if (options.privateKeyJwk) {
      var _fromJwk = fromJwk(options.privateKeyJwk),
          privateKeyBase58 = _fromJwk.privateKeyBase58;

      this.privateKeyBuffer = bs58.decode(privateKeyBase58);
    }
  }

  KeyPair.fingerprintFromPublicKey = function fingerprintFromPublicKey(keypair) {
    var kp = KeyPair_1.from(keypair);
    return kp.id.substring(1);
  };

  KeyPair.generateEphemeralKeyPair = function generateEphemeralKeyPair(epkArgs) {
    try {
      return Promise.resolve(getEpkGenerator(KeyPair_1, epkArgs)());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  KeyPair.kekFromEphemeralPeer = function kekFromEphemeralPeer(_ref) {
    var keyAgreementKey = _ref.keyAgreementKey,
        epk = _ref.epk;

    try {
      if (!(epk && typeof epk === 'object')) {
        throw new TypeError('"epk" must be an object.');
      } // convert to LD key for Web KMS


      var ephemeralPublicKey = new KeyPair_1({
        publicKeyJwk: epk
      }); // safe to use IDs like in rfc7518 or does
      // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?
      // "Party U Info"

      var producerInfo = ephemeralPublicKey.publicKeyBuffer; // "Party V Info"

      var consumerInfo = Buffer.from(keyAgreementKey.id); // converts keys again....
      // base58 encoding should only be used at the network / serialization boundary.

      return Promise.resolve(keyAgreementKey.deriveSecret({
        publicKey: ephemeralPublicKey.toJsonWebKeyPair()
      })).then(function (secret) {
        return Promise.resolve(deriveKey({
          secret: secret,
          producerInfo: producerInfo,
          consumerInfo: consumerInfo
        })).then(function (keyData) {
          return Promise.resolve(KeyEncryptionKey.createKek({
            keyData: keyData
          })).then(function (_KeyEncryptionKey$cre) {
            return {
              kek: _KeyEncryptionKey$cre
            };
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  KeyPair.kekFromStaticPeer = function kekFromStaticPeer(_ref2) {
    var ephemeralKeyPair = _ref2.ephemeralKeyPair,
        staticPublicKey = _ref2.staticPublicKey;

    try {
      if (staticPublicKey.type !== KEY_TYPE) {
        throw new Error("\"staticPublicKey.type\" must be \"" + KEY_TYPE + "\".");
      }

      return Promise.resolve(KeyPair_1.from(ephemeralKeyPair.keypair)).then(function (epkPair) {
        // "Party U Info"
        var producerInfo = epkPair.publicKeyBuffer; // "Party V Info"

        var consumerInfo = Buffer.from(staticPublicKey.id);
        return Promise.resolve(epkPair.deriveSecret({
          publicKey: staticPublicKey
        })).then(function (secret) {
          return Promise.resolve(deriveKey({
            secret: secret,
            producerInfo: producerInfo,
            consumerInfo: consumerInfo
          })).then(function (keyData) {
            return Promise.resolve(KeyEncryptionKey.createKek({
              keyData: keyData
            })).then(function (_KeyEncryptionKey$cre2) {
              return {
                kek: _KeyEncryptionKey$cre2,
                epk: ephemeralKeyPair.epk,
                apu: base64url.encode(producerInfo),
                apv: base64url.encode(consumerInfo)
              };
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _proto = KeyPair.prototype;

  _proto.fingerprint = function fingerprint() {
    var _this$toJsonWebKeyPai = this.toJsonWebKeyPair(),
        id = _this$toJsonWebKeyPai.id;

    return id.substring(1);
  };

  _proto.toKeyPair = function toKeyPair(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    var options = {
      id: this.id,
      type: 'UnsupportedVerificationMethod2020',
      controller: this.controller,
      publicKeyBase58: bs58.encode(this.publicKeyBuffer)
    };

    if (exportPrivateKey) {
      options.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);
    }

    return options;
  };

  _proto.toJsonWebKeyPair = function toJsonWebKeyPair(exportPrivateKey) {
    if (exportPrivateKey === void 0) {
      exportPrivateKey = false;
    }

    var options = this.toKeyPair(exportPrivateKey);
    return toJwkPair(options);
  };

  _proto.signer = function signer() {
    try {
      var _this2 = this;

      var _this2$toJsonWebKeyPa = _this2.toJsonWebKeyPair(true),
          privateKeyJwk = _this2$toJsonWebKeyPa.privateKeyJwk;

      return Promise.resolve(privateKeyToSigner(privateKeyJwk));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.verifier = function verifier() {
    try {
      var _this4 = this;

      var _this4$toJsonWebKeyPa = _this4.toJsonWebKeyPair(),
          publicKeyJwk = _this4$toJsonWebKeyPa.publicKeyJwk;

      return Promise.resolve(publicKeyToVerifier(publicKeyJwk));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.deriveSecret = function deriveSecret$1(options) {
    var _this$toJsonWebKeyPai2 = this.toJsonWebKeyPair(true),
        privateKeyJwk = _this$toJsonWebKeyPai2.privateKeyJwk;

    var publicKeyJwk;

    if (options.publicKey.publicKeyJwk) {
      publicKeyJwk = options.publicKey.publicKeyJwk;
    } else if (options.publicKey.publicKeyBase58) {
      var _toJwkPair = toJwkPair(options.publicKey);

      publicKeyJwk = _toJwkPair.publicKeyJwk;
    } else {
      throw new Error('Cannot deriveSecret from remote... publicKeyJwk or publicKeyBase58 must be present.');
    }

    return deriveSecret(privateKeyJwk, publicKeyJwk);
  };

  return KeyPair;
}();

KeyPair.JWE_ALG = 'ECDH-ES+A256KW';

KeyPair.generate = function (options) {
  try {
    return Promise.resolve(generate(options)).then(function (_ref3) {
      var privateKeyJwk = _ref3.privateKeyJwk;
      return new KeyPair_1(_extends({}, fromJwk(privateKeyJwk)));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

KeyPair.from = function (options) {
  return new KeyPair_1(_extends({}, options));
};

KeyPair.fromFingerprint = function (_ref4) {
  var fingerprint = _ref4.fingerprint;

  try {
    var data = getJwkTypeFromMultibase(fingerprint);

    if (data.kty) {
      var publicKeyBytes = bs58.decode(fingerprint.substring(1));
      var publicKeyBase58 = bs58.encode(publicKeyBytes.slice(3));
      return Promise.resolve(new KeyPair_1({
        id: '#' + fingerprint,
        controller: fingerprintToDid(fingerprint),
        type: 'JsonWebKey2020',
        publicKeyBase58: publicKeyBase58
      }));
    }

    throw new Error('Cannot create key from fingerprint ' + fingerprint);
  } catch (e) {
    return Promise.reject(e);
  }
};

KeyPair = KeyPair_1 = /*#__PURE__*/__decorate([/*#__PURE__*/staticImplements()], KeyPair);

var resolve = /*#__PURE__*/getResolve(KeyPair);
var get = /*#__PURE__*/getGet(resolve);

var driver = {
  __proto__: null,
  resolve: resolve,
  get: get
};

export { KeyPair, createDetachedJws, createJws, deriveSecret, driver, privateKeyToSigner, publicKeyToVerifier };
//# sourceMappingURL=did-key-web-crypto.esm.js.map
