import { sign, verify as verify$2 } from '@transmute/linked-data-proof';
import jsonld$2 from 'jsonld';
import { check } from 'jsonld-checker';
import moment from 'moment';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var ProofPurpose = /*#__PURE__*/function () {
  /**
   * @param term {string} the `proofPurpose` term, as defined in the
   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.
   * @param [date] {string or Date or integer} the expected date for
   *   the creation of the proof.
   * @param [maxTimestampDelta] {integer} a maximum number of seconds that
   *   the date on the signature can deviate from, defaults to `Infinity`.
   */
  function ProofPurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        term = _ref.term,
        date = _ref.date,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    if (term === undefined) {
      throw new Error('"term" is required.');
    }

    if (maxTimestampDelta !== undefined && typeof maxTimestampDelta !== 'number') {
      throw new TypeError('"maxTimestampDelta" must be a number.');
    }

    this.term = term;

    if (date !== undefined) {
      this.date = new Date(date);

      if (isNaN(this.date)) {
        throw TypeError("\"date\" \"" + date + "\" is not a valid date.");
      }
    }

    this.maxTimestampDelta = maxTimestampDelta;
  }
  /**
   * Called to validate the purpose of a proof. This method is called during
   * proof verification, after the proof value has been checked against the
   * given verification method (e.g. in the case of a digital signature, the
   * signature has been cryptographically verified against the public key).
   *
   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,
   *   with the matching purpose to validate.
   *
   * @return {Promise<object>} resolves to an object with `valid` and `error`.
   */


  var _proto = ProofPurpose.prototype;

  _proto.validate = function validate(proof, _options) {
    try {
      var _this2 = this;

      try {
        // check expiration
        if (_this2.maxTimestampDelta !== Infinity) {
          var expected = (_this2.date || new Date()).getTime();
          var delta = _this2.maxTimestampDelta * 1000;
          var created = new Date(proof.created).getTime(); // comparing this way handles NaN case where `created` is invalid

          if (!(created >= expected - delta && created <= expected + delta)) {
            throw new Error("The proof's created timestamp is out of range.");
          }
        }

        return Promise.resolve({
          valid: true
        });
      } catch (error) {
        return Promise.resolve({
          valid: false,
          error: error
        });
      }
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Called to update a proof when it is being created, adding any properties
   * specific to this purpose. This method is called prior to the proof
   * value being generated such that any properties added may be, for example,
   * included in a digital signature value.
   *
   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`
   *   to update.
   *
   * @return {Promise<object>} resolves to the proof instance (in the
   *   `constants.SECURITY_CONTEXT_URL`.
   */
  ;

  _proto.update = function update(proof, _options) {
    try {
      var _this4 = this;

      proof.proofPurpose = _this4.term;
      return Promise.resolve(proof);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Determines if the given proof has a purpose that matches this instance,
   * i.e. this ProofPurpose instance should be used to validate the given
   * proof.
   *
   * @param proof {object} the proof to check.
   *
   * @return {Promise<boolean>} `true` if there's a match, `false` if not.
   */
  ;

  _proto.match = function match(proof // { document, documentLoader, expansionMap }
  ) {
    try {
      var _this6 = this;

      return Promise.resolve(proof.proofPurpose === _this6.term);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ProofPurpose;
}();

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)
function _forTo(array, body, check) {
	var i = -1, pact, reject;
	function _cycle(result) {
		try {
			while (++i < array.length && (!check || !check())) {
				result = body(i);
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
						return;
					}
				}
			}
			if (pact) {
				_settle(pact, 1, result);
			} else {
				pact = result;
			}
		} catch (e) {
			_settle(pact || (pact = new _Pact()), 2, e);
		}
	}
	_cycle();
	return pact;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

// Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy
function _forOf(target, body, check) {
	if (typeof target[_iteratorSymbol] === "function") {
		var iterator = target[_iteratorSymbol](), step, pact, reject;
		function _cycle(result) {
			try {
				while (!(step = iterator.next()).done && (!check || !check())) {
					result = body(step.value);
					if (result && result.then) {
						if (_isSettledPact(result)) {
							result = result.v;
						} else {
							result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
							return;
						}
					}
				}
				if (pact) {
					_settle(pact, 1, result);
				} else {
					pact = result;
				}
			} catch (e) {
				_settle(pact || (pact = new _Pact()), 2, e);
			}
		}
		_cycle();
		if (iterator.return) {
			var _fixup = function(value) {
				try {
					if (!step.done) {
						iterator.return();
					}
				} catch(e) {
				}
				return value;
			};
			if (pact && pact.then) {
				return pact.then(_fixup, function(e) {
					throw _fixup(e);
				});
			}
			_fixup();
		}
		return pact;
	}
	// No support for Symbol.iterator
	if (!("length" in target)) {
		throw new TypeError("Object is not iterable");
	}
	// Handle live collections properly
	var values = [];
	for (var i = 0; i < target.length; i++) {
		values.push(target[i]);
	}
	return _forTo(values, function(i) { return body(values[i]); }, check);
}

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var _require = /*#__PURE__*/require('security-context'),
    securityConstants = _require.constants;

var _require2 = /*#__PURE__*/require('credentials-context'),
    credentialsConstants = _require2.constants;

var constants = {
  CREDENTIALS_CONTEXT_URL: 'https://www.w3.org/2018/credentials/v2',
  CREDENTIALS_CONTEXT_V1_URL: credentialsConstants.CREDENTIALS_CONTEXT_V1_URL,
  CREDENTIALS_CONTEXT_V2_URL: 'https://www.w3.org/2018/credentials/v2',
  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,
  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',
  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature'
};

var jsonld = /*#__PURE__*/require('jsonld');

var ControllerProofPurpose = /*#__PURE__*/function (_ProofPurpose) {
  _inheritsLoose(ControllerProofPurpose, _ProofPurpose);

  /**
   * Creates a proof purpose that will validate whether or not the verification
   * method in a proof was authorized by its declared controller for the
   * proof's purpose.
   *
   * @param term {string} the `proofPurpose` term, as defined in the
   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.
   * @param [controller] {object} the description of the controller, if it
   *   is not to be dereferenced via a `documentLoader`.
   * @param [date] {string or Date or integer} the expected date for
   *   the creation of the proof.
   * @param [maxTimestampDelta] {integer} a maximum number of seconds that
   *   the date on the signature can deviate from, defaults to `Infinity`.
   */
  function ControllerProofPurpose(_temp) {
    var _this;

    var _ref = _temp === void 0 ? {} : _temp,
        term = _ref.term,
        controller = _ref.controller,
        date = _ref.date,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    _this = _ProofPurpose.call(this, {
      term: term,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;

    if (controller !== undefined) {
      if (typeof controller !== 'object') {
        throw new TypeError('"controller" must be an object.');
      }

      _this.controller = controller;
    }

    return _this;
  }

  var _proto = ControllerProofPurpose.prototype;

  _proto.validate = function validate(proof, _options) {
    try {
      var _this3 = this;

      return Promise.resolve(_catch(function () {
        return Promise.resolve(_ProofPurpose.prototype.validate.call(_this3, proof, _options)).then(function (result) {
          var _exit = false;

          function _temp3(_result) {
            if (_exit) return _result;
            var verificationMethods = jsonld.getValues(result.controller, _this3.term);
            result.valid = verificationMethods.some(function (vm) {
              return vm === verificationId || typeof vm === 'object' && vm.id === verificationId;
            });

            if (!result.valid) {
              throw new Error("Verification method \"" + verificationMethod.id + "\" not authorized " + ("by controller for proof purpose \"" + _this3.term + "\"."));
            }

            return result;
          }

          if (!result.valid) {
            throw result.error;
          }

          var verificationMethod = _options.verificationMethod,
              documentLoader = _options.documentLoader;
          var verificationId = verificationMethod.id; // if no `controller` specified, use verification method's

          var _temp2 = function () {
            if (_this3.controller) {
              result.controller = _this3.controller;
            } else {
              var _jsonld$frame;

              // support legacy `owner` property
              var controller = verificationMethod.controller,
                  owner = verificationMethod.owner;
              var controllerId;

              if (controller) {
                if (typeof controller === 'object') {
                  controllerId = controller.id;
                } else if (typeof controller !== 'string') {
                  throw new TypeError('"controller" must be a string representing a URL.');
                } else {
                  controllerId = controller;
                }
              } else if (owner) {
                if (typeof owner === 'object') {
                  controllerId = owner.id;
                } else if (typeof owner !== 'string') {
                  throw new TypeError('"owner" must be a string representing a URL.');
                } else {
                  controllerId = owner;
                }
              } // Note: `expansionMap` is intentionally not passed; we can safely drop
              // properties here and must allow for it


              return Promise.resolve(jsonld.frame(controllerId, (_jsonld$frame = {
                '@context': constants.SECURITY_CONTEXT_URL,
                id: controllerId
              }, _jsonld$frame[_this3.term] = {
                '@embed': '@never',
                id: verificationId
              }, _jsonld$frame), {
                documentLoader: documentLoader,
                compactToRelative: false
              })).then(function (_ref2) {
                var _ref2$Graph = _ref2['@graph'],
                    _ref2$Graph$ = _ref2$Graph[0],
                    framed = _ref2$Graph$ === void 0 ? {} : _ref2$Graph$;
                result.controller = framed;
              });
            }
          }();

          return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);
        });
      }, function (error) {
        return {
          valid: false,
          error: error
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ControllerProofPurpose;
}(ProofPurpose);

var AssertionProofPurpose = /*#__PURE__*/function (_ControllerProofPurpo) {
  _inheritsLoose(AssertionProofPurpose, _ControllerProofPurpo);

  function AssertionProofPurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$term = _ref.term,
        term = _ref$term === void 0 ? 'assertionMethod' : _ref$term,
        controller = _ref.controller,
        date = _ref.date,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    return _ControllerProofPurpo.call(this, {
      term: term,
      controller: controller,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;
  }

  return AssertionProofPurpose;
}(ControllerProofPurpose);

var jsonld$1 = /*#__PURE__*/require('jsonld');
/**
 * Creates a proof purpose that will validate whether or not the verification
 * method in a proof was authorized by its declared controller for the
 * proof's purpose.
 */


var CredentialIssuancePurpose = /*#__PURE__*/function (_AssertionProofPurpos) {
  _inheritsLoose(CredentialIssuancePurpose, _AssertionProofPurpos);

  /**
   * @param {object} options - The options to use.
   * @param {object} [options.controller] - The description of the controller,
   *   if it is not to be dereferenced via a `documentLoader`.
   * @param {string|Date|number} [options.date] - The expected date for
   *   the creation of the proof.
   * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number
   *   of seconds that the date on the signature can deviate from.
   */
  function CredentialIssuancePurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        controller = _ref.controller,
        date = _ref.date,
        maxTimestampDelta = _ref.maxTimestampDelta;

    return _AssertionProofPurpos.call(this, {
      controller: controller,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;
  }
  /**
   * Validates the purpose of a proof. This method is called during
   * proof verification, after the proof value has been checked against the
   * given verification method (in the case of a digital signature, the
   * signature has been cryptographically verified against the public key).
   *
   * @param {object} proof - The proof to validate.
   * @param {object} options - The options to use.
   * @param {object} options.document - The document whose signature is
   *   being verified.
   * @param {object} options.suite - Signature suite used in
   *   the proof.
   * @param {string} options.verificationMethod - Key id URL to the paired
   *   public key.
   * @param {object} [options.documentLoader] - A document loader.
   * @param {object} [options.expansionMap] - An expansion map.
   *
   * @throws {Error} If verification method not authorized by controller.
   * @throws {Error} If proof's created timestamp is out of range.
   *
   * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.
   */


  var _proto = CredentialIssuancePurpose.prototype;

  _proto.validate = function validate(proof, _ref2) {
    var document = _ref2.document,
        suite = _ref2.suite,
        verificationMethod = _ref2.verificationMethod,
        documentLoader = _ref2.documentLoader,
        expansionMap = _ref2.expansionMap;

    try {
      var _this2 = this;

      return Promise.resolve(_catch(function () {
        return Promise.resolve(_AssertionProofPurpos.prototype.validate.call(_this2, proof, {
          document: document,
          suite: suite,
          verificationMethod: verificationMethod,
          documentLoader: documentLoader,
          expansionMap: expansionMap
        })).then(function (result) {
          if (!result.valid) {
            throw result.error;
          }

          var issuer = jsonld$1.getValues(document, 'https://www.w3.org/2018/credentials#issuer');

          if (!issuer || issuer.length === 0) {
            throw new Error('Credential issuer is required.');
          }

          if (result.controller.id !== issuer[0].id) {
            throw new Error('Credential issuer must match the verification method controller.');
          }

          return {
            valid: true
          };
        });
      }, function (error) {
        return {
          valid: false,
          error: error
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return CredentialIssuancePurpose;
}(AssertionProofPurpose);

var AuthenticationProofPurpose = /*#__PURE__*/function (_ControllerProofPurpo) {
  _inheritsLoose(AuthenticationProofPurpose, _ControllerProofPurpo);

  function AuthenticationProofPurpose(_temp) {
    var _this;

    var _ref = _temp === void 0 ? {} : _temp,
        _ref$term = _ref.term,
        term = _ref$term === void 0 ? 'authentication' : _ref$term,
        controller = _ref.controller,
        challenge = _ref.challenge,
        date = _ref.date,
        domain = _ref.domain,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    _this = _ControllerProofPurpo.call(this, {
      term: term,
      controller: controller,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;

    if (typeof challenge !== 'string') {
      throw new TypeError('"challenge" must be a string.');
    }

    if (domain !== undefined && typeof domain !== 'string') {
      throw new TypeError('"domain" must be a string.');
    }

    _this.challenge = challenge;
    _this.domain = domain;
    return _this;
  }

  var _proto = AuthenticationProofPurpose.prototype;

  _proto.validate = function validate(proof, _ref2) {
    var verificationMethod = _ref2.verificationMethod,
        documentLoader = _ref2.documentLoader,
        expansionMap = _ref2.expansionMap;

    try {
      var _this3 = this;

      try {
        // check challenge
        if (proof.challenge !== _this3.challenge) {
          throw new Error('The challenge is not as expected; ' + ("challenge=\"" + proof.challenge + "\", expected=\"" + _this3.challenge + "\""));
        } // check domain


        if (_this3.domain !== undefined && proof.domain !== _this3.domain) {
          throw new Error('The domain is not as expected; ' + ("domain=\"" + proof.domain + "\", expected=\"" + _this3.domain + "\""));
        }

        return Promise.resolve(_ControllerProofPurpo.prototype.validate.call(_this3, proof, {
          verificationMethod: verificationMethod,
          documentLoader: documentLoader,
          expansionMap: expansionMap
        }));
      } catch (error) {
        return Promise.resolve({
          valid: false,
          error: error
        });
      }
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.update = function update(proof, _options) {
    try {
      var _this5 = this;

      return Promise.resolve(_ControllerProofPurpo.prototype.update.call(_this5, proof, _options)).then(function (_ControllerProofPurpo2) {
        proof = _ControllerProofPurpo2;
        proof.challenge = _this5.challenge;

        if (_this5.domain !== undefined) {
          proof.domain = _this5.domain;
        }

        return proof;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return AuthenticationProofPurpose;
}(ControllerProofPurpose);

var dateRegex = /*#__PURE__*/new RegExp('^(\\d{4})-(0[1-9]|1[0-2])-' + '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' + '([0-5][0-9]):([0-5][0-9]|60)' + '(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):' + '([0-5][0-9]))$', 'i');

function _getId(obj) {
  if (typeof obj === 'string') {
    return obj;
  }

  if (!('id' in obj)) {
    return;
  }

  return obj.id;
}

var checkCredential = function checkCredential(credential, documentLoader) {
  try {
    // ensure first context is 'https://www.w3.org/2018/credentials/v1'
    if (typeof credential === 'string') {
      // might be a JWT... in which case... there is no way to validate....
      return Promise.resolve();
    }

    return Promise.resolve(check(credential, documentLoader)).then(function (isValidJsonLd) {
      if (!isValidJsonLd.ok) {
        throw new Error("credential is not valid JSON-LD: " + JSON.stringify(isValidJsonLd.error, null, 2));
      } // if (credential['@context'][0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {
      //   throw new Error(
      //     `"${constants.CREDENTIALS_CONTEXT_V1_URL}" needs to be first in the ` +
      //       'list of contexts.'
      //   );
      // }
      // check type presence and cardinality


      if (!credential['type']) {
        throw new Error('"type" property is required.');
      }

      if (!jsonld$2.getValues(credential, 'type').includes('VerifiableCredential')) {
        throw new Error('"type" must include `VerifiableCredential`.');
      }

      if (!credential['credentialSubject']) {
        throw new Error('"credentialSubject" property is required.');
      }

      if (!credential['issuer']) {
        throw new Error('"issuer" property is required.');
      } // check issuanceDate cardinality


      if (jsonld$2.getValues(credential, 'issuanceDate').length > 1) {
        throw new Error('"issuanceDate" property can only have one value.');
      } // check issued is a date


      if (!credential['issuanceDate']) {
        throw new Error('"issuanceDate" property is required.');
      }

      if ('issuanceDate' in credential) {
        if (!dateRegex.test(credential.issuanceDate)) {
          throw new Error("\"issuanceDate\" must be a valid date: " + credential.issuanceDate);
        }
      } // check issuer cardinality


      if (jsonld$2.getValues(credential, 'issuer').length > 1) {
        throw new Error('"issuer" property can only have one value.');
      } // check issuer is a URL
      // FIXME


      if ('issuer' in credential) {
        var issuer = _getId(credential.issuer);

        if (!issuer) {
          throw new Error("\"issuer\" id is required.");
        }

        if (!issuer.includes(':')) {
          throw new Error("\"issuer\" id must be a URL: " + issuer);
        }
      }

      if ('credentialStatus' in credential) {
        if (!credential.credentialStatus.id) {
          throw new Error('"credentialStatus" must include an id.');
        }

        if (!credential.credentialStatus.type) {
          throw new Error('"credentialStatus" must include a type.');
        }
      } // check evidences are URLs
      // FIXME


      jsonld$2.getValues(credential, 'evidence').forEach(function (evidence) {
        var evidenceId = _getId(evidence);

        if (evidenceId && !evidenceId.includes(':')) {
          throw new Error("\"evidence\" id must be a URL: " + evidence);
        }
      }); // check expires is a date

      if ('expirationDate' in credential && !dateRegex.test(credential.expirationDate)) {
        throw new Error("\"expirationDate\" must be a valid date: " + credential.expirationDate);
      }
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var issue = function issue(options) {
  try {
    var credential = options.credential,
        suite = options.suite,
        documentLoader = options.documentLoader; // run common credential checks

    if (!credential) {
      throw new TypeError('"credential" parameter is required for issuing.');
    }

    return Promise.resolve(checkCredential(credential, documentLoader)).then(function () {
      if (!documentLoader) {
        throw new TypeError('"documentLoader" parameter is required for issuing.');
      }

      if (!suite) {
        throw new TypeError('"suite" parameter is required for issuing.');
      } // check to make sure the `suite` has required params
      // Note: verificationMethod defaults to publicKey.id, in suite constructor...
      // ...in some implementations...


      if (!suite.verificationMethod) {
        throw new TypeError('"suite.verificationMethod" property is required.');
      }

      var purpose = options.purpose || new CredentialIssuancePurpose();
      return sign(credential, _extends({
        purpose: purpose
      }, options));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var checkPresentation = function checkPresentation(presentation) {
  // normalize to an array to allow the common case of context being a string
  // const context = Array.isArray(presentation['@context'])
  //   ? presentation['@context']
  //   : [presentation['@context']];
  // ensure first context is 'https://www.w3.org/2018/credentials/v1'
  // if (context[0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {
  //   throw new Error(
  //     `"${constants.CREDENTIALS_CONTEXT_V1_URL}" needs to be first in the ` +
  //       'list of contexts.'
  //   );
  // }
  var types = jsonld$2.getValues(presentation, 'type'); // check type presence

  if (!types.includes('VerifiablePresentation')) {
    throw new Error('"type" must include "VerifiablePresentation".');
  }
};

var _verifyCredential = function _verifyCredential(options) {
  try {
    var credential = options.credential,
        checkStatus = options.checkStatus,
        documentLoader = options.documentLoader; // run common credential checks

    return Promise.resolve(checkCredential(credential, documentLoader)).then(function () {
      // if credential status is provided, a `checkStatus` function must be given
      if (credential.credentialStatus && typeof options.checkStatus !== 'function') {
        throw new TypeError('A "checkStatus" function must be given to verify credentials with ' + '"credentialStatus".');
      }

      var controller = options.controller;
      var purpose = options.purpose || new CredentialIssuancePurpose({
        controller: controller
      });
      return Promise.resolve(verify$2(credential, _extends({
        purpose: purpose
      }, options))).then(function (result) {
        // if verification has already failed, skip status check
        if (!result.verified) {
          return result;
        }

        var _temp = function () {
          if (credential.credentialStatus) {
            return Promise.resolve(checkStatus(options)).then(function (_checkStatus) {
              result.statusResult = _checkStatus;

              if (!result.statusResult.verified) {
                result.verified = false;
              }
            });
          }
        }();

        return _temp && _temp.then ? _temp.then(function () {
          return result;
        }) : result;
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyCredential = function verifyCredential(options) {
  try {
    var credential = options.credential;

    try {
      if (!credential) {
        throw new TypeError('A "credential" property is required for verifying.');
      }

      return _verifyCredential(options);
    } catch (error) {
      return Promise.resolve({
        verified: false,
        results: [{
          credential: credential,
          verified: false,
          error: error
        }],
        error: error
      });
    }
  } catch (e) {
    return Promise.reject(e);
  }
};

var _verifyPresentation = function _verifyPresentation(options) {
  try {
    var _temp4 = function _temp4() {
      if (unsignedPresentation) {
        // No need to verify the proof section of this presentation
        return {
          verified: verified,
          results: [presentation],
          credentialResults: credentialResults
        };
      }

      var controller = options.controller,
          domain = options.domain,
          challenge = options.challenge;

      if (!options.presentationPurpose && !challenge) {
        throw new Error('A "challenge" param is required for AuthenticationProofPurpose.');
      }

      var purpose = options.presentationPurpose || new AuthenticationProofPurpose({
        controller: controller,
        domain: domain,
        challenge: challenge
      });
      return Promise.resolve(verify$2(presentation, _extends({
        purpose: purpose
      }, options))).then(function (presentationResult) {
        return {
          presentationResult: presentationResult,
          verified: verified && presentationResult.verified,
          credentialResults: credentialResults,
          error: presentationResult.error
        };
      });
    };

    var presentation = options.presentation,
        unsignedPresentation = options.unsignedPresentation;
    checkPresentation(presentation); // FIXME: verify presentation first, then each individual credential
    // only if that proof is verified
    // if verifiableCredentials are present, verify them, individually

    var credentialResults;
    var verified = true;
    var credentials = jsonld$2.getValues(presentation, 'verifiableCredential');

    var _temp5 = function () {
      if (credentials.length > 0) {
        // verify every credential in `verifiableCredential`
        return Promise.resolve(Promise.all(credentials.map(function (credential) {
          return verifyCredential(_extends({
            credential: credential
          }, options));
        }))).then(function (_Promise$all) {
          credentialResults = _Promise$all;
          credentialResults = credentialResults.map(function (cr, i) {
            cr.credentialId = credentials[i].id;
            return cr;
          });
          var allCredentialsVerified = credentialResults.every(function (r) {
            return r.verified;
          });

          if (!allCredentialsVerified) {
            verified = false;
          }
        });
      }
    }();

    return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
  } catch (e) {
    return Promise.reject(e);
  }
};

var verify = function verify(options) {
  try {
    if (!options.documentLoader) {
      throw new TypeError('"documentLoader" parameter is required for verifying.');
    }

    var presentation = options.presentation;

    try {
      if (!presentation) {
        throw new TypeError('A "presentation" property is required for verifying.');
      }

      return _verifyPresentation(options);
    } catch (error) {
      return Promise.resolve({
        verified: false,
        results: [{
          presentation: presentation,
          verified: false,
          error: error
        }],
        error: error
      });
    }
  } catch (e) {
    return Promise.reject(e);
  }
};

var createPresentation = function createPresentation(_temp5) {
  var _ref = _temp5 === void 0 ? {} : _temp5,
      verifiableCredential = _ref.verifiableCredential,
      id = _ref.id,
      holder = _ref.holder,
      documentLoader = _ref.documentLoader;

  try {
    var _temp6 = function _temp6() {
      if (id) {
        presentation.id = id;
      }

      if (holder) {
        presentation.holder = holder;
      }

      checkPresentation(presentation);
      return presentation;
    };

    var presentation = {
      '@context': [constants.CREDENTIALS_CONTEXT_V1_URL],
      type: ['VerifiablePresentation']
    };

    var _temp7 = function () {
      if (verifiableCredential) {
        var _temp8 = function _temp8() {
          presentation.verifiableCredential = _credentials;
        };

        var _credentials = [].concat(verifiableCredential); // ensure all credentials are valid


        var _temp9 = _forOf(_credentials, function (credential) {
          return Promise.resolve(checkCredential(credential, documentLoader)).then(function () {});
        });

        return _temp9 && _temp9.then ? _temp9.then(_temp8) : _temp8(_temp9);
      }
    }();

    return Promise.resolve(_temp7 && _temp7.then ? _temp7.then(_temp6) : _temp6(_temp7));
  } catch (e) {
    return Promise.reject(e);
  }
};
var signPresentation = function signPresentation(options) {
  if (options === void 0) {
    options = {};
  }

  try {
    var _options = options,
        presentation = _options.presentation,
        domain = _options.domain,
        challenge = _options.challenge,
        documentLoader = _options.documentLoader;
    var purpose = options.purpose || new AuthenticationProofPurpose({
      domain: domain,
      challenge: challenge
    });

    if (!documentLoader) {
      throw new TypeError('"documentLoader" parameter is required for issuing.');
    }

    return Promise.resolve(sign(presentation, _extends({
      purpose: purpose
    }, options)));
  } catch (e) {
    return Promise.reject(e);
  }
};



var index = {
  __proto__: null,
  issue: issue,
  verifyCredential: verifyCredential,
  verify: verify,
  createPresentation: createPresentation,
  signPresentation: signPresentation
};

var isObject = function isObject(data) {
  if (Array.isArray(data)) {
    return false;
  }

  if ((typeof data === 'object' || typeof data === 'function') && data !== null) {
    return true;
  }

  return false;
};

var issue$1 = function issue(credentialTemplate, signer, documentLoader) {
  try {
    if (credentialTemplate.issuer === undefined) {
      throw new Error('Verifiable Credentials require an "issuer".');
    }

    if (credentialTemplate.credentialSubject === undefined || credentialTemplate.credentialSubject.id === undefined) {
      throw new Error('Verifiable Credentials require an "subject".');
    }

    var issuer = isObject(credentialTemplate.issuer) ? credentialTemplate.issuer.id : credentialTemplate.issuer;
    var subject = credentialTemplate.credentialSubject.id;
    return Promise.resolve(checkCredential(credentialTemplate, documentLoader)).then(function () {
      var payload = {
        iss: issuer,
        sub: subject,
        vc: credentialTemplate
      };

      if (credentialTemplate.id) {
        payload.jti = credentialTemplate.id;
      }

      if (credentialTemplate.issuanceDate) {
        payload.nbf = moment(credentialTemplate.issuanceDate).unix();
      }

      if (credentialTemplate.expirationDate) {
        payload.exp = moment(credentialTemplate.expirationDate).unix();
      } // console.log(JSON.stringify(payload, null, 2))


      var header = {};
      return signer.sign(payload, header);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createPresentation$1 = function createPresentation$1(credentials, holder, id) {
  try {
    return Promise.resolve(createPresentation({
      verifiableCredential: credentials,
      holder: holder,
      id: id
    })).then(function (vp) {
      var payload = {
        iss: holder,
        sub: holder,
        vp: vp
      };

      if (vp.id) {
        payload.jti = vp.id;
      }

      return payload;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var provePresentation = function provePresentation(vp, options, signer) {
  if (options.challenge) {
    vp.nonce = options.challenge;
  }

  if (options.domain) {
    vp.aud = options.domain;
  }

  var header = {};
  return signer.sign(vp, header);
};

var verify$1 = function verify(jws, verifier) {
  return verifier.verify(jws);
};



var index$1 = {
  __proto__: null,
  issue: issue$1,
  createPresentation: createPresentation$1,
  provePresentation: provePresentation,
  verify: verify$1
};

export { index$1 as jwt, index as ld };
//# sourceMappingURL=vc.js.esm.js.map
