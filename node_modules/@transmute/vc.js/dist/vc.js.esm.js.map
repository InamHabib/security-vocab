{"version":3,"file":"vc.js.esm.js","sources":["../src/vc-ld/purposes/ProofPurpose.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/vc-ld/constants.ts","../src/vc-ld/purposes/ControllerProofPurpose.ts","../src/vc-ld/purposes/AssertionProofPurpose.ts","../src/vc-ld/purposes/CredentialIssuancePurpose.ts","../src/vc-ld/purposes/AuthenticationProofPurpose.ts","../src/vc-ld/checkCredential.ts","../src/vc-ld/issue.ts","../src/vc-ld/checkPresentation.ts","../src/vc-ld/verify.ts","../src/vc-ld/prove.ts","../src/vc-jwt/issue.ts","../src/vc-jwt/prove.ts","../src/vc-jwt/verify.ts"],"sourcesContent":["import { IPurposeValidateOptions } from '../../types';\n\nexport class ProofPurpose {\n  public term: any;\n  public date: any;\n  public maxTimestampDelta: any;\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({ term, date, maxTimestampDelta = Infinity }: any = {}) {\n    if (term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if (\n      maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number'\n    ) {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if (date !== undefined) {\n      this.date = new Date(date);\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(proof: any, _options: IPurposeValidateOptions) {\n    try {\n      // check expiration\n      if (this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if (!(created >= expected - delta && created <= expected + delta)) {\n          throw new Error(\"The proof's created timestamp is out of range.\");\n        }\n      }\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof: any, _options: IPurposeValidateOptions) {\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(\n    proof: any\n    // { document, documentLoader, expansionMap }\n  ) {\n    return proof.proofPurpose === this.term;\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","const { constants: securityConstants } = require('security-context');\nconst { constants: credentialsConstants } = require('credentials-context');\nexport default {\n  CREDENTIALS_CONTEXT_URL: 'https://www.w3.org/2018/credentials/v2',\n  CREDENTIALS_CONTEXT_V1_URL: credentialsConstants.CREDENTIALS_CONTEXT_V1_URL,\n  CREDENTIALS_CONTEXT_V2_URL: 'https://www.w3.org/2018/credentials/v2',\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature',\n};\n","import { ProofPurpose } from './ProofPurpose';\nimport constants from '../constants';\n\nimport { IPurposeValidateOptions } from '../../types';\n\nconst jsonld = require('jsonld');\n\nexport class ControllerProofPurpose extends ProofPurpose {\n  public controller: any;\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({\n    term,\n    controller,\n    date,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, date, maxTimestampDelta });\n    if (controller !== undefined) {\n      if (typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n  }\n\n  async validate(proof: any, _options: IPurposeValidateOptions) {\n    try {\n      const result: any = await super.validate(proof, _options);\n      if (!result.valid) {\n        throw result.error;\n      }\n\n      const { verificationMethod, documentLoader } = _options;\n\n      const { id: verificationId } = verificationMethod;\n\n      // if no `controller` specified, use verification method's\n      if (this.controller) {\n        result.controller = this.controller;\n      } else {\n        // support legacy `owner` property\n        const { controller, owner } = verificationMethod;\n        let controllerId;\n        if (controller) {\n          if (typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if (typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.'\n            );\n          } else {\n            controllerId = controller;\n          }\n        } else if (owner) {\n          if (typeof owner === 'object') {\n            controllerId = owner.id;\n          } else if (typeof owner !== 'string') {\n            throw new TypeError('\"owner\" must be a string representing a URL.');\n          } else {\n            controllerId = owner;\n          }\n        }\n        // Note: `expansionMap` is intentionally not passed; we can safely drop\n        // properties here and must allow for it\n        const {\n          '@graph': [framed = {}],\n        } = await jsonld.frame(\n          controllerId,\n          {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // the term should be in the json-ld object the controllerId resolves\n            // to.\n            [this.term]: {\n              '@embed': '@never',\n              id: verificationId,\n            },\n          },\n          { documentLoader, compactToRelative: false }\n        );\n        result.controller = framed;\n      }\n      const verificationMethods = jsonld.getValues(\n        result.controller,\n        this.term\n      );\n      result.valid = verificationMethods.some(\n        (vm: any) =>\n          vm === verificationId ||\n          (typeof vm === 'object' && vm.id === verificationId)\n      );\n      if (!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n            `by controller for proof purpose \"${this.term}\".`\n        );\n      }\n      return result;\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n}\n","import { ControllerProofPurpose } from './ControllerProofPurpose';\n\nexport class AssertionProofPurpose extends ControllerProofPurpose {\n  constructor({\n    term = 'assertionMethod',\n    controller,\n    date,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, controller, date, maxTimestampDelta });\n  }\n}\n","import { AssertionProofPurpose } from './AssertionProofPurpose';\nconst jsonld = require('jsonld');\n\n/**\n * Creates a proof purpose that will validate whether or not the verification\n * method in a proof was authorized by its declared controller for the\n * proof's purpose.\n */\nexport class CredentialIssuancePurpose extends AssertionProofPurpose {\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} [options.controller] - The description of the controller,\n   *   if it is not to be dereferenced via a `documentLoader`.\n   * @param {string|Date|number} [options.date] - The expected date for\n   *   the creation of the proof.\n   * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number\n   *   of seconds that the date on the signature can deviate from.\n   */\n  constructor({ controller, date, maxTimestampDelta }: any = {}) {\n    super({ controller, date, maxTimestampDelta });\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param {object} proof - The proof to validate.\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document whose signature is\n   *   being verified.\n   * @param {object} options.suite - Signature suite used in\n   *   the proof.\n   * @param {string} options.verificationMethod - Key id URL to the paired\n   *   public key.\n   * @param {object} [options.documentLoader] - A document loader.\n   * @param {object} [options.expansionMap] - An expansion map.\n   *\n   * @throws {Error} If verification method not authorized by controller.\n   * @throws {Error} If proof's created timestamp is out of range.\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.\n   */\n  async validate(\n    proof: any,\n    { document, suite, verificationMethod, documentLoader, expansionMap }: any\n  ) {\n    try {\n      const result = await super.validate(proof, {\n        document,\n        suite,\n        verificationMethod,\n        documentLoader,\n        expansionMap,\n      });\n\n      if (!result.valid) {\n        throw result.error;\n      }\n\n      const issuer = jsonld.getValues(\n        document,\n        'https://www.w3.org/2018/credentials#issuer'\n      );\n\n      if (!issuer || issuer.length === 0) {\n        throw new Error('Credential issuer is required.');\n      }\n\n      if (result.controller.id !== issuer[0].id) {\n        throw new Error(\n          'Credential issuer must match the verification method controller.'\n        );\n      }\n\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n}\n\nexport default CredentialIssuancePurpose;\n","import { ControllerProofPurpose } from './ControllerProofPurpose';\nimport { IPurposeValidateOptions } from '../../types';\n\nexport class AuthenticationProofPurpose extends ControllerProofPurpose {\n  public challenge: string;\n  public domain: string;\n  constructor({\n    term = 'authentication',\n    controller,\n    challenge,\n    date,\n    domain,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, controller, date, maxTimestampDelta });\n    if (typeof challenge !== 'string') {\n      throw new TypeError('\"challenge\" must be a string.');\n    }\n    if (domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    this.challenge = challenge;\n    this.domain = domain;\n  }\n\n  async validate(\n    proof: any,\n    {\n      verificationMethod,\n      documentLoader,\n      expansionMap,\n    }: IPurposeValidateOptions\n  ) {\n    try {\n      // check challenge\n      if (proof.challenge !== this.challenge) {\n        throw new Error(\n          'The challenge is not as expected; ' +\n            `challenge=\"${proof.challenge}\", expected=\"${this.challenge}\"`\n        );\n      }\n\n      // check domain\n      if (this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error(\n          'The domain is not as expected; ' +\n            `domain=\"${proof.domain}\", expected=\"${this.domain}\"`\n        );\n      }\n\n      return super.validate(proof, {\n        verificationMethod,\n        documentLoader,\n        expansionMap,\n      });\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n\n  async update(proof: any, _options: IPurposeValidateOptions) {\n    proof = await super.update(proof, _options);\n    proof.challenge = this.challenge;\n    if (this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    return proof;\n  }\n}\n","import jsonld from 'jsonld';\nimport { check } from 'jsonld-checker';\n// import constants from './constants';\n\nconst dateRegex = new RegExp(\n  '^(\\\\d{4})-(0[1-9]|1[0-2])-' +\n    '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]):([0-5][0-9]|60)' +\n    '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]))$',\n  'i'\n);\n\nfunction _getId(obj: any) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n\n  if (!('id' in obj)) {\n    return;\n  }\n\n  return obj.id;\n}\n\nexport const checkCredential = async (credential: any, documentLoader: any) => {\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (typeof credential === 'string') {\n    // might be a JWT... in which case... there is no way to validate....\n    return;\n  }\n  const isValidJsonLd = await check(credential, documentLoader);\n  if (!isValidJsonLd.ok) {\n    throw new Error(\n      `credential is not valid JSON-LD: ${JSON.stringify(\n        isValidJsonLd.error,\n        null,\n        2\n      )}`\n    );\n  }\n\n  // if (credential['@context'][0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {\n  //   throw new Error(\n  //     `\"${constants.CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n  //       'list of contexts.'\n  //   );\n  // }\n\n  // check type presence and cardinality\n  if (!credential['type']) {\n    throw new Error('\"type\" property is required.');\n  }\n\n  if (!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n\n  if (!credential['credentialSubject']) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  if (!credential['issuer']) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if (jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if (!credential['issuanceDate']) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n\n  if ('issuanceDate' in credential) {\n    if (!dateRegex.test(credential.issuanceDate)) {\n      throw new Error(\n        `\"issuanceDate\" must be a valid date: ${credential.issuanceDate}`\n      );\n    }\n  }\n\n  // check issuer cardinality\n  if (jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  // FIXME\n  if ('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if (!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    if (!issuer.includes(':')) {\n      throw new Error(`\"issuer\" id must be a URL: ${issuer}`);\n    }\n  }\n\n  if ('credentialStatus' in credential) {\n    if (!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if (!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  // FIXME\n  jsonld.getValues(credential, 'evidence').forEach((evidence: any) => {\n    const evidenceId = _getId(evidence);\n    if (evidenceId && !evidenceId.includes(':')) {\n      throw new Error(`\"evidence\" id must be a URL: ${evidence}`);\n    }\n  });\n\n  // check expires is a date\n  if (\n    'expirationDate' in credential &&\n    !dateRegex.test(credential.expirationDate)\n  ) {\n    throw new Error(\n      `\"expirationDate\" must be a valid date: ${credential.expirationDate}`\n    );\n  }\n};\n","import { sign } from '@transmute/linked-data-proof';\nimport { IIssueOptions } from '../types';\nimport { CredentialIssuancePurpose } from './purposes';\nimport { checkCredential } from './checkCredential';\n\nexport const issue = async (options: IIssueOptions) => {\n  const { credential, suite, documentLoader } = options;\n\n  // run common credential checks\n  if (!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n  await checkCredential(credential, documentLoader);\n\n  if (!documentLoader) {\n    throw new TypeError('\"documentLoader\" parameter is required for issuing.');\n  }\n\n  if (!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor...\n  // ...in some implementations...\n  if (!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n\n  const purpose = options.purpose || new CredentialIssuancePurpose();\n\n  return sign(credential, { purpose, ...options });\n};\n","import jsonld from 'jsonld';\n// import constants from './constants';\n\nexport const checkPresentation = (presentation: any) => {\n  // normalize to an array to allow the common case of context being a string\n  // const context = Array.isArray(presentation['@context'])\n  //   ? presentation['@context']\n  //   : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  // if (context[0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {\n  //   throw new Error(\n  //     `\"${constants.CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n  //       'list of contexts.'\n  //   );\n  // }\n\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if (!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n};\n","import jsonld from 'jsonld';\nimport { verify as jSigsVerify } from '@transmute/linked-data-proof';\nimport { IVerifyOptions } from '../types';\nimport { checkPresentation } from './checkPresentation';\nimport { checkCredential } from './checkCredential';\nimport {\n  AuthenticationProofPurpose,\n  CredentialIssuancePurpose,\n} from './purposes';\n\nconst _verifyCredential = async (options: IVerifyOptions) => {\n  const { credential, checkStatus, documentLoader } = options;\n\n  // run common credential checks\n  await checkCredential(credential, documentLoader);\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if (\n    credential.credentialStatus &&\n    typeof options.checkStatus !== 'function'\n  ) {\n    throw new TypeError(\n      'A \"checkStatus\" function must be given to verify credentials with ' +\n        '\"credentialStatus\".'\n    );\n  }\n\n  const { controller } = options;\n  const purpose =\n    options.purpose ||\n    new CredentialIssuancePurpose({\n      controller,\n    });\n\n  const result = await jSigsVerify(credential, {\n    purpose,\n    ...options,\n  });\n\n  // if verification has already failed, skip status check\n  if (!result.verified) {\n    return result;\n  }\n\n  if (credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if (!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n\n  return result;\n};\n\nexport const verifyCredential = async (options: IVerifyOptions) => {\n  const { credential } = options;\n  try {\n    if (!credential) {\n      throw new TypeError('A \"credential\" property is required for verifying.');\n    }\n    return _verifyCredential(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{ credential, verified: false, error }],\n      error,\n    };\n  }\n};\n\nconst _verifyPresentation = async (options: IVerifyOptions) => {\n  const { presentation, unsignedPresentation } = options;\n\n  checkPresentation(presentation);\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults: any;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if (credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(\n      credentials.map((credential: any) => {\n        return verifyCredential({ credential, ...options });\n      })\n    );\n\n    credentialResults = credentialResults.map((cr: any, i: any) => {\n      cr.credentialId = credentials[i].id;\n      return cr;\n    });\n\n    const allCredentialsVerified = credentialResults.every(\n      (r: any) => r.verified\n    );\n    if (!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n\n  if (unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return { verified, results: [presentation], credentialResults };\n  }\n\n  const { controller, domain, challenge } = options;\n  if (!options.presentationPurpose && !challenge) {\n    throw new Error(\n      'A \"challenge\" param is required for AuthenticationProofPurpose.'\n    );\n  }\n\n  const purpose =\n    options.presentationPurpose ||\n    new AuthenticationProofPurpose({ controller, domain, challenge });\n\n  const presentationResult = await jSigsVerify(presentation, {\n    purpose,\n    ...options,\n  });\n\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error,\n  };\n};\nexport const verify = async (options: IVerifyOptions) => {\n  if (!options.documentLoader) {\n    throw new TypeError(\n      '\"documentLoader\" parameter is required for verifying.'\n    );\n  }\n  const { presentation } = options;\n  try {\n    if (!presentation) {\n      throw new TypeError(\n        'A \"presentation\" property is required for verifying.'\n      );\n    }\n    return _verifyPresentation(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{ presentation, verified: false, error }],\n      error,\n    };\n  }\n};\n","import { sign } from '@transmute/linked-data-proof';\nimport { checkPresentation } from './checkPresentation';\nimport { checkCredential } from './checkCredential';\nimport constants from './constants';\n\nimport { AuthenticationProofPurpose } from './purposes';\n\nexport const createPresentation = async ({\n  verifiableCredential,\n  id,\n  holder,\n  documentLoader,\n}: any = {}) => {\n  const presentation: any = {\n    '@context': [constants.CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation'],\n  };\n  if (verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for (const credential of credentials) {\n      await checkCredential(credential, documentLoader);\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if (id) {\n    presentation.id = id;\n  }\n  if (holder) {\n    presentation.holder = holder;\n  }\n\n  checkPresentation(presentation);\n\n  return presentation;\n};\n\nexport const signPresentation = async (options: any = {}) => {\n  const { presentation, domain, challenge, documentLoader } = options;\n  const purpose =\n    options.purpose ||\n    new AuthenticationProofPurpose({\n      domain,\n      challenge,\n    });\n\n  if (!documentLoader) {\n    throw new TypeError('\"documentLoader\" parameter is required for issuing.');\n  }\n\n  return sign(presentation, { purpose, ...options });\n};\n","import moment from 'moment';\nimport { IVcJwtPayload } from '../types';\nimport { checkCredential } from '../vc-ld/checkCredential';\n\nconst isObject = (data: any) => {\n  if (Array.isArray(data)) {\n    return false;\n  }\n  if (\n    (typeof data === 'object' || typeof data === 'function') &&\n    data !== null\n  ) {\n    return true;\n  }\n  return false;\n};\nexport const issue = async (\n  credentialTemplate: any,\n  signer: any,\n  documentLoader: any\n) => {\n  if (credentialTemplate.issuer === undefined) {\n    throw new Error('Verifiable Credentials require an \"issuer\".');\n  }\n\n  if (\n    credentialTemplate.credentialSubject === undefined ||\n    credentialTemplate.credentialSubject.id === undefined\n  ) {\n    throw new Error('Verifiable Credentials require an \"subject\".');\n  }\n\n  let issuer = isObject(credentialTemplate.issuer)\n    ? credentialTemplate.issuer.id\n    : credentialTemplate.issuer;\n\n  let subject = credentialTemplate.credentialSubject.id;\n\n  await checkCredential(credentialTemplate, documentLoader);\n\n  const payload: IVcJwtPayload = {\n    iss: issuer,\n    sub: subject,\n    vc: credentialTemplate,\n  };\n\n  if (credentialTemplate.id) {\n    payload.jti = credentialTemplate.id;\n  }\n\n  if (credentialTemplate.issuanceDate) {\n    payload.nbf = moment(credentialTemplate.issuanceDate).unix();\n  }\n\n  if (credentialTemplate.expirationDate) {\n    payload.exp = moment(credentialTemplate.expirationDate).unix();\n  }\n  // console.log(JSON.stringify(payload, null, 2))\n  const header = {};\n  return signer.sign(payload, header);\n};\n","import { IVcJwtPressentationPayload, IVpOptions } from '../types';\n\nimport { createPresentation as createVerifiablePresentation } from '../vc-ld/prove';\n\nexport const createPresentation = async (\n  credentials: any[],\n  holder: string,\n  id?: string\n) => {\n  const vp = await createVerifiablePresentation({\n    verifiableCredential: credentials, //array of <object|string> | object | string.... thanks for that...\n    holder,\n    id,\n  });\n\n  const payload: IVcJwtPressentationPayload = {\n    iss: holder,\n    sub: holder,\n    vp: vp,\n  };\n\n  if (vp.id) {\n    payload.jti = vp.id;\n  }\n  return payload;\n};\n\nexport const provePresentation = (\n  vp: any,\n  options: IVpOptions,\n  signer: any\n) => {\n  if (options.challenge) {\n    vp.nonce = options.challenge;\n  }\n  if (options.domain) {\n    vp.aud = options.domain;\n  }\n  const header = {};\n  return signer.sign(vp, header);\n};\n","export const verify = (jws: string, verifier: any) => {\n  return verifier.verify(jws);\n};\n"],"names":["ProofPurpose","term","date","maxTimestampDelta","Infinity","undefined","Error","TypeError","Date","isNaN","validate","proof","_options","expected","getTime","delta","created","valid","error","update","proofPurpose","match","require","securityConstants","constants","credentialsConstants","CREDENTIALS_CONTEXT_URL","CREDENTIALS_CONTEXT_V1_URL","CREDENTIALS_CONTEXT_V2_URL","SECURITY_CONTEXT_URL","SECURITY_CONTEXT_V2_URL","SECURITY_CONTEXT_V1_URL","SECURITY_PROOF_URL","SECURITY_SIGNATURE_URL","jsonld","ControllerProofPurpose","controller","result","verificationMethods","getValues","some","vm","verificationId","id","verificationMethod","documentLoader","owner","controllerId","frame","compactToRelative","framed","AssertionProofPurpose","CredentialIssuancePurpose","document","suite","expansionMap","issuer","length","AuthenticationProofPurpose","challenge","domain","dateRegex","RegExp","_getId","obj","checkCredential","credential","check","isValidJsonLd","ok","JSON","stringify","includes","test","issuanceDate","credentialStatus","type","forEach","evidence","evidenceId","expirationDate","issue","options","purpose","sign","checkPresentation","presentation","types","_verifyCredential","checkStatus","jSigsVerify","verified","statusResult","verifyCredential","results","_verifyPresentation","unsignedPresentation","credentialResults","presentationPurpose","presentationResult","credentials","Promise","all","map","cr","i","credentialId","allCredentialsVerified","every","r","verify","createPresentation","verifiableCredential","holder","concat","signPresentation","isObject","data","Array","isArray","credentialTemplate","signer","credentialSubject","subject","payload","iss","sub","vc","jti","nbf","moment","unix","exp","header","createVerifiablePresentation","vp","provePresentation","nonce","aud","jws","verifier"],"mappings":"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"}