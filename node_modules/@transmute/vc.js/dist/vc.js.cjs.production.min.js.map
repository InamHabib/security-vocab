{"version":3,"file":"vc.js.cjs.production.min.js","sources":["../src/vc-ld/purposes/ProofPurpose.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/vc-ld/constants.ts","../src/vc-ld/purposes/ControllerProofPurpose.ts","../src/vc-ld/purposes/AssertionProofPurpose.ts","../src/vc-ld/purposes/CredentialIssuancePurpose.ts","../src/vc-ld/purposes/AuthenticationProofPurpose.ts","../src/vc-ld/checkCredential.ts","../src/vc-ld/checkPresentation.ts","../src/vc-ld/verify.ts","../src/vc-ld/prove.ts","../src/vc-ld/issue.ts","../src/vc-jwt/issue.ts","../src/vc-jwt/prove.ts","../src/vc-jwt/verify.ts"],"sourcesContent":["import { IPurposeValidateOptions } from '../../types';\n\nexport class ProofPurpose {\n  public term: any;\n  public date: any;\n  public maxTimestampDelta: any;\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({ term, date, maxTimestampDelta = Infinity }: any = {}) {\n    if (term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if (\n      maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number'\n    ) {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if (date !== undefined) {\n      this.date = new Date(date);\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(proof: any, _options: IPurposeValidateOptions) {\n    try {\n      // check expiration\n      if (this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if (!(created >= expected - delta && created <= expected + delta)) {\n          throw new Error(\"The proof's created timestamp is out of range.\");\n        }\n      }\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof: any, _options: IPurposeValidateOptions) {\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(\n    proof: any\n    // { document, documentLoader, expansionMap }\n  ) {\n    return proof.proofPurpose === this.term;\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","const { constants: securityConstants } = require('security-context');\nconst { constants: credentialsConstants } = require('credentials-context');\nexport default {\n  CREDENTIALS_CONTEXT_URL: 'https://www.w3.org/2018/credentials/v2',\n  CREDENTIALS_CONTEXT_V1_URL: credentialsConstants.CREDENTIALS_CONTEXT_V1_URL,\n  CREDENTIALS_CONTEXT_V2_URL: 'https://www.w3.org/2018/credentials/v2',\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature',\n};\n","import { ProofPurpose } from './ProofPurpose';\nimport constants from '../constants';\n\nimport { IPurposeValidateOptions } from '../../types';\n\nconst jsonld = require('jsonld');\n\nexport class ControllerProofPurpose extends ProofPurpose {\n  public controller: any;\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({\n    term,\n    controller,\n    date,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, date, maxTimestampDelta });\n    if (controller !== undefined) {\n      if (typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n  }\n\n  async validate(proof: any, _options: IPurposeValidateOptions) {\n    try {\n      const result: any = await super.validate(proof, _options);\n      if (!result.valid) {\n        throw result.error;\n      }\n\n      const { verificationMethod, documentLoader } = _options;\n\n      const { id: verificationId } = verificationMethod;\n\n      // if no `controller` specified, use verification method's\n      if (this.controller) {\n        result.controller = this.controller;\n      } else {\n        // support legacy `owner` property\n        const { controller, owner } = verificationMethod;\n        let controllerId;\n        if (controller) {\n          if (typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if (typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.'\n            );\n          } else {\n            controllerId = controller;\n          }\n        } else if (owner) {\n          if (typeof owner === 'object') {\n            controllerId = owner.id;\n          } else if (typeof owner !== 'string') {\n            throw new TypeError('\"owner\" must be a string representing a URL.');\n          } else {\n            controllerId = owner;\n          }\n        }\n        // Note: `expansionMap` is intentionally not passed; we can safely drop\n        // properties here and must allow for it\n        const {\n          '@graph': [framed = {}],\n        } = await jsonld.frame(\n          controllerId,\n          {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // the term should be in the json-ld object the controllerId resolves\n            // to.\n            [this.term]: {\n              '@embed': '@never',\n              id: verificationId,\n            },\n          },\n          { documentLoader, compactToRelative: false }\n        );\n        result.controller = framed;\n      }\n      const verificationMethods = jsonld.getValues(\n        result.controller,\n        this.term\n      );\n      result.valid = verificationMethods.some(\n        (vm: any) =>\n          vm === verificationId ||\n          (typeof vm === 'object' && vm.id === verificationId)\n      );\n      if (!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n            `by controller for proof purpose \"${this.term}\".`\n        );\n      }\n      return result;\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n}\n","import { ControllerProofPurpose } from './ControllerProofPurpose';\n\nexport class AssertionProofPurpose extends ControllerProofPurpose {\n  constructor({\n    term = 'assertionMethod',\n    controller,\n    date,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, controller, date, maxTimestampDelta });\n  }\n}\n","import { AssertionProofPurpose } from './AssertionProofPurpose';\nconst jsonld = require('jsonld');\n\n/**\n * Creates a proof purpose that will validate whether or not the verification\n * method in a proof was authorized by its declared controller for the\n * proof's purpose.\n */\nexport class CredentialIssuancePurpose extends AssertionProofPurpose {\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} [options.controller] - The description of the controller,\n   *   if it is not to be dereferenced via a `documentLoader`.\n   * @param {string|Date|number} [options.date] - The expected date for\n   *   the creation of the proof.\n   * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number\n   *   of seconds that the date on the signature can deviate from.\n   */\n  constructor({ controller, date, maxTimestampDelta }: any = {}) {\n    super({ controller, date, maxTimestampDelta });\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param {object} proof - The proof to validate.\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document whose signature is\n   *   being verified.\n   * @param {object} options.suite - Signature suite used in\n   *   the proof.\n   * @param {string} options.verificationMethod - Key id URL to the paired\n   *   public key.\n   * @param {object} [options.documentLoader] - A document loader.\n   * @param {object} [options.expansionMap] - An expansion map.\n   *\n   * @throws {Error} If verification method not authorized by controller.\n   * @throws {Error} If proof's created timestamp is out of range.\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.\n   */\n  async validate(\n    proof: any,\n    { document, suite, verificationMethod, documentLoader, expansionMap }: any\n  ) {\n    try {\n      const result = await super.validate(proof, {\n        document,\n        suite,\n        verificationMethod,\n        documentLoader,\n        expansionMap,\n      });\n\n      if (!result.valid) {\n        throw result.error;\n      }\n\n      const issuer = jsonld.getValues(\n        document,\n        'https://www.w3.org/2018/credentials#issuer'\n      );\n\n      if (!issuer || issuer.length === 0) {\n        throw new Error('Credential issuer is required.');\n      }\n\n      if (result.controller.id !== issuer[0].id) {\n        throw new Error(\n          'Credential issuer must match the verification method controller.'\n        );\n      }\n\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n}\n\nexport default CredentialIssuancePurpose;\n","import { ControllerProofPurpose } from './ControllerProofPurpose';\nimport { IPurposeValidateOptions } from '../../types';\n\nexport class AuthenticationProofPurpose extends ControllerProofPurpose {\n  public challenge: string;\n  public domain: string;\n  constructor({\n    term = 'authentication',\n    controller,\n    challenge,\n    date,\n    domain,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, controller, date, maxTimestampDelta });\n    if (typeof challenge !== 'string') {\n      throw new TypeError('\"challenge\" must be a string.');\n    }\n    if (domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    this.challenge = challenge;\n    this.domain = domain;\n  }\n\n  async validate(\n    proof: any,\n    {\n      verificationMethod,\n      documentLoader,\n      expansionMap,\n    }: IPurposeValidateOptions\n  ) {\n    try {\n      // check challenge\n      if (proof.challenge !== this.challenge) {\n        throw new Error(\n          'The challenge is not as expected; ' +\n            `challenge=\"${proof.challenge}\", expected=\"${this.challenge}\"`\n        );\n      }\n\n      // check domain\n      if (this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error(\n          'The domain is not as expected; ' +\n            `domain=\"${proof.domain}\", expected=\"${this.domain}\"`\n        );\n      }\n\n      return super.validate(proof, {\n        verificationMethod,\n        documentLoader,\n        expansionMap,\n      });\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n\n  async update(proof: any, _options: IPurposeValidateOptions) {\n    proof = await super.update(proof, _options);\n    proof.challenge = this.challenge;\n    if (this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    return proof;\n  }\n}\n","import jsonld from 'jsonld';\nimport { check } from 'jsonld-checker';\n// import constants from './constants';\n\nconst dateRegex = new RegExp(\n  '^(\\\\d{4})-(0[1-9]|1[0-2])-' +\n    '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]):([0-5][0-9]|60)' +\n    '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]))$',\n  'i'\n);\n\nfunction _getId(obj: any) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n\n  if (!('id' in obj)) {\n    return;\n  }\n\n  return obj.id;\n}\n\nexport const checkCredential = async (credential: any, documentLoader: any) => {\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (typeof credential === 'string') {\n    // might be a JWT... in which case... there is no way to validate....\n    return;\n  }\n  const isValidJsonLd = await check(credential, documentLoader);\n  if (!isValidJsonLd.ok) {\n    throw new Error(\n      `credential is not valid JSON-LD: ${JSON.stringify(\n        isValidJsonLd.error,\n        null,\n        2\n      )}`\n    );\n  }\n\n  // if (credential['@context'][0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {\n  //   throw new Error(\n  //     `\"${constants.CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n  //       'list of contexts.'\n  //   );\n  // }\n\n  // check type presence and cardinality\n  if (!credential['type']) {\n    throw new Error('\"type\" property is required.');\n  }\n\n  if (!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n\n  if (!credential['credentialSubject']) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  if (!credential['issuer']) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if (jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if (!credential['issuanceDate']) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n\n  if ('issuanceDate' in credential) {\n    if (!dateRegex.test(credential.issuanceDate)) {\n      throw new Error(\n        `\"issuanceDate\" must be a valid date: ${credential.issuanceDate}`\n      );\n    }\n  }\n\n  // check issuer cardinality\n  if (jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  // FIXME\n  if ('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if (!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    if (!issuer.includes(':')) {\n      throw new Error(`\"issuer\" id must be a URL: ${issuer}`);\n    }\n  }\n\n  if ('credentialStatus' in credential) {\n    if (!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if (!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  // FIXME\n  jsonld.getValues(credential, 'evidence').forEach((evidence: any) => {\n    const evidenceId = _getId(evidence);\n    if (evidenceId && !evidenceId.includes(':')) {\n      throw new Error(`\"evidence\" id must be a URL: ${evidence}`);\n    }\n  });\n\n  // check expires is a date\n  if (\n    'expirationDate' in credential &&\n    !dateRegex.test(credential.expirationDate)\n  ) {\n    throw new Error(\n      `\"expirationDate\" must be a valid date: ${credential.expirationDate}`\n    );\n  }\n};\n","import jsonld from 'jsonld';\n// import constants from './constants';\n\nexport const checkPresentation = (presentation: any) => {\n  // normalize to an array to allow the common case of context being a string\n  // const context = Array.isArray(presentation['@context'])\n  //   ? presentation['@context']\n  //   : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  // if (context[0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {\n  //   throw new Error(\n  //     `\"${constants.CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n  //       'list of contexts.'\n  //   );\n  // }\n\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if (!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n};\n","import jsonld from 'jsonld';\nimport { verify as jSigsVerify } from '@transmute/linked-data-proof';\nimport { IVerifyOptions } from '../types';\nimport { checkPresentation } from './checkPresentation';\nimport { checkCredential } from './checkCredential';\nimport {\n  AuthenticationProofPurpose,\n  CredentialIssuancePurpose,\n} from './purposes';\n\nconst _verifyCredential = async (options: IVerifyOptions) => {\n  const { credential, checkStatus, documentLoader } = options;\n\n  // run common credential checks\n  await checkCredential(credential, documentLoader);\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if (\n    credential.credentialStatus &&\n    typeof options.checkStatus !== 'function'\n  ) {\n    throw new TypeError(\n      'A \"checkStatus\" function must be given to verify credentials with ' +\n        '\"credentialStatus\".'\n    );\n  }\n\n  const { controller } = options;\n  const purpose =\n    options.purpose ||\n    new CredentialIssuancePurpose({\n      controller,\n    });\n\n  const result = await jSigsVerify(credential, {\n    purpose,\n    ...options,\n  });\n\n  // if verification has already failed, skip status check\n  if (!result.verified) {\n    return result;\n  }\n\n  if (credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if (!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n\n  return result;\n};\n\nexport const verifyCredential = async (options: IVerifyOptions) => {\n  const { credential } = options;\n  try {\n    if (!credential) {\n      throw new TypeError('A \"credential\" property is required for verifying.');\n    }\n    return _verifyCredential(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{ credential, verified: false, error }],\n      error,\n    };\n  }\n};\n\nconst _verifyPresentation = async (options: IVerifyOptions) => {\n  const { presentation, unsignedPresentation } = options;\n\n  checkPresentation(presentation);\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults: any;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if (credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(\n      credentials.map((credential: any) => {\n        return verifyCredential({ credential, ...options });\n      })\n    );\n\n    credentialResults = credentialResults.map((cr: any, i: any) => {\n      cr.credentialId = credentials[i].id;\n      return cr;\n    });\n\n    const allCredentialsVerified = credentialResults.every(\n      (r: any) => r.verified\n    );\n    if (!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n\n  if (unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return { verified, results: [presentation], credentialResults };\n  }\n\n  const { controller, domain, challenge } = options;\n  if (!options.presentationPurpose && !challenge) {\n    throw new Error(\n      'A \"challenge\" param is required for AuthenticationProofPurpose.'\n    );\n  }\n\n  const purpose =\n    options.presentationPurpose ||\n    new AuthenticationProofPurpose({ controller, domain, challenge });\n\n  const presentationResult = await jSigsVerify(presentation, {\n    purpose,\n    ...options,\n  });\n\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error,\n  };\n};\nexport const verify = async (options: IVerifyOptions) => {\n  if (!options.documentLoader) {\n    throw new TypeError(\n      '\"documentLoader\" parameter is required for verifying.'\n    );\n  }\n  const { presentation } = options;\n  try {\n    if (!presentation) {\n      throw new TypeError(\n        'A \"presentation\" property is required for verifying.'\n      );\n    }\n    return _verifyPresentation(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{ presentation, verified: false, error }],\n      error,\n    };\n  }\n};\n","import { sign } from '@transmute/linked-data-proof';\nimport { checkPresentation } from './checkPresentation';\nimport { checkCredential } from './checkCredential';\nimport constants from './constants';\n\nimport { AuthenticationProofPurpose } from './purposes';\n\nexport const createPresentation = async ({\n  verifiableCredential,\n  id,\n  holder,\n  documentLoader,\n}: any = {}) => {\n  const presentation: any = {\n    '@context': [constants.CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation'],\n  };\n  if (verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for (const credential of credentials) {\n      await checkCredential(credential, documentLoader);\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if (id) {\n    presentation.id = id;\n  }\n  if (holder) {\n    presentation.holder = holder;\n  }\n\n  checkPresentation(presentation);\n\n  return presentation;\n};\n\nexport const signPresentation = async (options: any = {}) => {\n  const { presentation, domain, challenge, documentLoader } = options;\n  const purpose =\n    options.purpose ||\n    new AuthenticationProofPurpose({\n      domain,\n      challenge,\n    });\n\n  if (!documentLoader) {\n    throw new TypeError('\"documentLoader\" parameter is required for issuing.');\n  }\n\n  return sign(presentation, { purpose, ...options });\n};\n","import { sign } from '@transmute/linked-data-proof';\nimport { IIssueOptions } from '../types';\nimport { CredentialIssuancePurpose } from './purposes';\nimport { checkCredential } from './checkCredential';\n\nexport const issue = async (options: IIssueOptions) => {\n  const { credential, suite, documentLoader } = options;\n\n  // run common credential checks\n  if (!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n  await checkCredential(credential, documentLoader);\n\n  if (!documentLoader) {\n    throw new TypeError('\"documentLoader\" parameter is required for issuing.');\n  }\n\n  if (!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor...\n  // ...in some implementations...\n  if (!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n\n  const purpose = options.purpose || new CredentialIssuancePurpose();\n\n  return sign(credential, { purpose, ...options });\n};\n","import moment from 'moment';\nimport { IVcJwtPayload } from '../types';\nimport { checkCredential } from '../vc-ld/checkCredential';\n\nconst isObject = (data: any) => {\n  if (Array.isArray(data)) {\n    return false;\n  }\n  if (\n    (typeof data === 'object' || typeof data === 'function') &&\n    data !== null\n  ) {\n    return true;\n  }\n  return false;\n};\nexport const issue = async (\n  credentialTemplate: any,\n  signer: any,\n  documentLoader: any\n) => {\n  if (credentialTemplate.issuer === undefined) {\n    throw new Error('Verifiable Credentials require an \"issuer\".');\n  }\n\n  if (\n    credentialTemplate.credentialSubject === undefined ||\n    credentialTemplate.credentialSubject.id === undefined\n  ) {\n    throw new Error('Verifiable Credentials require an \"subject\".');\n  }\n\n  let issuer = isObject(credentialTemplate.issuer)\n    ? credentialTemplate.issuer.id\n    : credentialTemplate.issuer;\n\n  let subject = credentialTemplate.credentialSubject.id;\n\n  await checkCredential(credentialTemplate, documentLoader);\n\n  const payload: IVcJwtPayload = {\n    iss: issuer,\n    sub: subject,\n    vc: credentialTemplate,\n  };\n\n  if (credentialTemplate.id) {\n    payload.jti = credentialTemplate.id;\n  }\n\n  if (credentialTemplate.issuanceDate) {\n    payload.nbf = moment(credentialTemplate.issuanceDate).unix();\n  }\n\n  if (credentialTemplate.expirationDate) {\n    payload.exp = moment(credentialTemplate.expirationDate).unix();\n  }\n  // console.log(JSON.stringify(payload, null, 2))\n  const header = {};\n  return signer.sign(payload, header);\n};\n","import { IVcJwtPressentationPayload, IVpOptions } from '../types';\n\nimport { createPresentation as createVerifiablePresentation } from '../vc-ld/prove';\n\nexport const createPresentation = async (\n  credentials: any[],\n  holder: string,\n  id?: string\n) => {\n  const vp = await createVerifiablePresentation({\n    verifiableCredential: credentials, //array of <object|string> | object | string.... thanks for that...\n    holder,\n    id,\n  });\n\n  const payload: IVcJwtPressentationPayload = {\n    iss: holder,\n    sub: holder,\n    vp: vp,\n  };\n\n  if (vp.id) {\n    payload.jti = vp.id;\n  }\n  return payload;\n};\n\nexport const provePresentation = (\n  vp: any,\n  options: IVpOptions,\n  signer: any\n) => {\n  if (options.challenge) {\n    vp.nonce = options.challenge;\n  }\n  if (options.domain) {\n    vp.aud = options.domain;\n  }\n  const header = {};\n  return signer.sign(vp, header);\n};\n","export const verify = (jws: string, verifier: any) => {\n  return verifier.verify(jws);\n};\n"],"names":["ProofPurpose","term","date","maxTimestampDelta","Infinity","undefined","Error","TypeError","Date","isNaN","this","validate","proof","_options","expected","getTime","delta","created","valid","error","update","proofPurpose","match","_Pact","prototype","then","onFulfilled","onRejected","result","state","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_catch","body","recover","asyncIterator","securityConstants","require","constants","CREDENTIALS_CONTEXT_URL","CREDENTIALS_CONTEXT_V1_URL","CREDENTIALS_CONTEXT_V2_URL","SECURITY_CONTEXT_URL","SECURITY_CONTEXT_V2_URL","SECURITY_CONTEXT_V1_URL","SECURITY_PROOF_URL","SECURITY_SIGNATURE_URL","jsonld","ControllerProofPurpose","controller","verificationMethods","getValues","_this3","some","vm","verificationId","id","verificationMethod","documentLoader","controllerId","owner","frame","compactToRelative","AssertionProofPurpose","_ControllerProofPurpo","CredentialIssuancePurpose","_AssertionProofPurpos","document","suite","expansionMap","issuer","length","AuthenticationProofPurpose","challenge","domain","_this5","dateRegex","RegExp","_getId","obj","checkCredential","credential","check","isValidJsonLd","ok","JSON","stringify","includes","test","issuanceDate","credentialStatus","type","forEach","evidence","evidenceId","expirationDate","checkPresentation","presentation","verifyCredential","options","checkStatus","purpose","jSigsVerify","verified","statusResult","_verifyCredential","results","createPresentation","verifiableCredential","holder","credentials","concat","target","step","reject","_cycle","next","done","return","_fixup","values","i","push","array","_forTo","sign","credentialResults","unsignedPresentation","presentationPurpose","presentationResult","Promise","all","map","cr","credentialId","every","r","_verifyPresentation","credentialTemplate","signer","credentialSubject","data","Array","isArray","subject","payload","iss","sub","vc","jti","nbf","moment","unix","exp","createVerifiablePresentation","vp","nonce","aud","jws","verifier","verify"],"mappings":"ojBAEaA,4CAYqD,KAAlDC,IAAAA,KAAMC,IAAAA,SAAMC,kBAAAA,aAAoBC,mBAC/BC,IAATJ,QACI,IAAIK,MAAM,+BAGMD,IAAtBF,GAC6B,iBAAtBA,QAED,IAAII,UAAU,iDAEjBN,KAAOA,OACCI,IAATH,SACGA,KAAO,IAAIM,KAAKN,GACjBO,MAAMC,KAAKR,aACPK,qBAAqBL,iCAG1BC,kBAAoBA,6BAcrBQ,kBAASC,EAAYC,cAGQT,WAA3BM,KAAKP,kBAAgC,KACjCW,GADJJ,KACqBR,MAAQ,IAAIM,MAAQO,UACrCC,EAAiC,IAFrCN,KAEiBP,kBACbc,EAAU,IAAIT,KAAKI,EAAMK,SAASF,eAElCE,GAAWH,EAAWE,GAASC,GAAWH,EAAWE,SACnD,IAAIV,MAAM,yEAGb,CAAEY,OAAO,IAChB,MAAOC,0BACA,CAAED,OAAO,EAAOC,MAAAA,2CAgBrBC,gBAAOR,EAAYC,cACvBD,EAAMS,aAAeX,KAAKT,qBACnBW,yCAYHU,eACJV,8BAGOA,EAAMS,eAAiBX,KAAKT,+CC5FhC,MAAMsB,EAAqB,WACjC,SAASA,KAiCT,OAhCAA,EAAMC,UAAUC,KAAO,SAASC,EAAaC,GAC5C,MAAMC,EAAS,IAAIL,EACbM,EAAQnB,KAAKoB,EACnB,GAAID,EAAO,CACV,MAAME,EAAmB,EAARF,EAAYH,EAAcC,EAC3C,GAAII,EAAU,CACb,IACCC,EAAQJ,EAAQ,EAAGG,EAASrB,KAAKuB,IAChC,MAAOC,GACRF,EAAQJ,EAAQ,EAAGM,GAEpB,OAAON,EAEP,OAAOlB,KAiBT,OAdAA,KAAKyB,EAAI,SAASC,GACjB,IACC,MAAMC,EAAQD,EAAMH,EACN,EAAVG,EAAMN,EACTE,EAAQJ,EAAQ,EAAGF,EAAcA,EAAYW,GAASA,GAC5CV,EACVK,EAAQJ,EAAQ,EAAGD,EAAWU,IAE9BL,EAAQJ,EAAQ,EAAGS,GAEnB,MAAOH,GACRF,EAAQJ,EAAQ,EAAGM,KAGdN,GAEDL,EAlC0B,GAsClC,SAAgBS,EAAQM,EAAMT,EAAOQ,GACpC,IAAKC,EAAKR,EAAG,CACZ,GAAIO,aAAiBd,EAAO,CAC3B,IAAIc,EAAMP,EAOT,YADAO,EAAMF,EAAIH,EAAQO,KAAK,KAAMD,EAAMT,IALvB,EAARA,IACHA,EAAQQ,EAAMP,GAEfO,EAAQA,EAAMJ,EAMhB,GAAII,GAASA,EAAMZ,KAElB,YADAY,EAAMZ,KAAKO,EAAQO,KAAK,KAAMD,EAAMT,GAAQG,EAAQO,KAAK,KAAMD,EAAM,IAGtEA,EAAKR,EAAID,EACTS,EAAKL,EAAII,EACT,MAAMG,EAAWF,EAAKH,EAClBK,GACHA,EAASF,IAKL,SAASG,EAAeC,GAC9B,OAAOA,aAAoBnB,GAAsB,EAAbmB,EAASZ,EAkG9C,MAAaa,EAAkD,oBAAXC,OAA0BA,OAAOC,WAAaD,OAAOC,SAAWD,OAAO,oBAAuB,aA8Y3I,SAASE,EAAOC,EAAMC,GAC5B,IACC,IAAIpB,EAASmB,IACZ,MAAMb,GACP,OAAOc,EAAQd,GAEhB,OAAIN,GAAUA,EAAOH,KACbG,EAAOH,UAAK,EAAQuB,GAErBpB,EA1V4D,oBAAXgB,SAA0BA,OAAOK,gBAAkBL,OAAOK,cAAgBL,OAAO,8BCjOvHM,EAAsBC,QAAQ,oBAAzCC,YAEO,CACbC,wBAAyB,yCACzBC,2BAH0CH,QAAQ,uBAA5CC,UAG2CE,2BACjDC,2BAA4B,yCAC5BC,qBAAsBN,EAAkBO,wBACxCC,wBAAyBR,EAAkBQ,wBAC3CD,wBAAyBP,EAAkBO,wBAC3CE,mBAAoB,kCACpBC,uBAAwB,uCCLpBC,EAASV,QAAQ,UAEVW,+CAqBF,KAHPC,IAAAA,eAEA5D,mCAEM,CAAEF,OALRA,KAKcC,OAHdA,KAGoBC,6BAFAC,wBAGDC,IAAf0D,EAA0B,IACF,iBAAfA,QACH,IAAIxD,UAAU,qCAEjBwD,WAAaA,qCAIhBpD,kBAASC,EAAYC,0FAESF,gBAASC,EAAOC,mBAA1Ce,qBAuDAoC,EAAsBH,EAAOI,UACjCrC,EAAOmC,WACPG,EAAKjE,SAEP2B,EAAOV,MAAQ8C,EAAoBG,MACjC,SAACC,UACCA,IAAOC,GACQ,iBAAPD,GAAmBA,EAAGE,KAAOD,MAEpCzC,EAAOV,YACJ,IAAIZ,MACR,wBAAwBiE,EAAmBD,GAA3C,qDACsCJ,EAAKjE,kBAGxC2B,MArEFA,EAAOV,YACJU,EAAOT,UAGPoD,EAAuC1D,EAAvC0D,mBAAoBC,EAAmB3D,EAAnB2D,eAEhBH,EAAmBE,EAAvBD,oBAGJJ,EAAKH,kBAKHU,EADIV,EAAsBQ,EAAtBR,WAAYW,EAAUH,EAAVG,SAEhBX,KACwB,iBAAfA,EACTU,EAAeV,EAAWO,OACrB,CAAA,GAA0B,iBAAfP,QACV,IAAIxD,UACR,qDAGFkE,EAAeV,OAEZ,GAAIW,KACY,iBAAVA,EACTD,EAAeC,EAAMJ,OAChB,CAAA,GAAqB,iBAAVI,QACV,IAAInE,UAAU,gDAEpBkE,EAAeC,yBAOTb,EAAOc,MACfF,iBAEcrB,EAAUI,qBACtBc,GAAIG,KAGHP,EAAKjE,MAAO,UACD,SACVqE,GAAID,MAGR,CAAEG,eAAAA,EAAgBI,mBAAmB,+BAbrC,aAeFhD,EAAOmC,sBAfe,QA3BtBnC,EAAOmC,WAAaG,EAAKH,4DA4DpB5C,SACA,CAAED,OAAO,EAAOC,MAAAA,8CAzGenB,GCL/B6E,6CAMF,SAJP5E,SAGAE,yBAEA2E,YAAM,CAAE7E,gBALD,oBAKO8D,aAJdA,WAI0B7D,OAH1BA,KAGgCC,6BAFZC,oCALmB0D,GCDrCD,EAASV,QAAQ,UAOV4B,6CAUgD,YACzDC,YAAM,CAAEjB,aADIA,WACQ7D,OADIA,KACEC,oBADIA,oDA0B1BQ,kBACJC,SACEqE,IAAAA,SAAUC,IAAAA,MAAOX,IAAAA,mBAAoBC,IAAAA,eAAgBW,IAAAA,oGAG1BxE,gBAASC,EAAO,CACzCqE,SAAAA,EACAC,MAAAA,EACAX,mBAAAA,EACAC,eAAAA,EACAW,aAAAA,oBALIvD,OAQDA,EAAOV,YACJU,EAAOT,UAGTiE,EAASvB,EAAOI,UACpBgB,EACA,kDAGGG,GAA4B,IAAlBA,EAAOC,aACd,IAAI/E,MAAM,qCAGdsB,EAAOmC,WAAWO,KAAOc,EAAO,GAAGd,SAC/B,IAAIhE,MACR,0EAIG,CAAEY,OAAO,kBACTC,SACA,CAAED,OAAO,EAAOC,MAAAA,8CAtEkB0D,GCLlCS,+CAUF,SANPrF,KAEAsF,IAAAA,UAEAC,IAAAA,WACArF,mCAEM,CAAEF,gBAPD,mBAOO8D,aANdA,WAM0B7D,OAJ1BA,KAIgCC,6BAFZC,mBAGK,iBAAdmF,QACH,IAAIhF,UAAU,yCAEPF,IAAXmF,GAA0C,iBAAXA,QAC3B,IAAIjF,UAAU,uCAEjBgF,UAAYA,IACZC,OAASA,sCAGV7E,kBACJC,SAEE2D,IAAAA,mBACAC,IAAAA,eACAW,IAAAA,wBAKIvE,EAAM2E,YAAc7E,KAAK6E,gBACrB,IAAIjF,MACR,gDACgBM,EAAM2E,0BAHF7E,KAGgC6E,uBAKpClF,IARIK,KAQf8E,QAAwB5E,EAAM4E,SARf9E,KAQ+B8E,aAC/C,IAAIlF,MACR,0CACaM,EAAM4E,uBAXC9E,KAW0B8E,+CAIrC7E,cAfWD,KAeFE,EAAO,CAC3B2D,mBAAAA,EACAC,eAAAA,EACAW,aAAAA,KAEF,MAAOhE,0BACA,CAAED,OAAO,EAAOC,MAAAA,2CAIrBC,gBAAOR,EAAYC,qDACHO,cAAOR,EAAOC,6BAAlCD,KACM2E,UAAYE,EAAKF,eACHlF,IAAhBoF,EAAKD,SACP5E,EAAM4E,OAASC,EAAKD,QAEf5E,4CA/DqCkD,GCC1C4B,EAAY,IAAIC,OACpB,4JAKA,KAGF,SAASC,EAAOC,SACK,iBAARA,EACFA,EAGH,OAAQA,EAIPA,EAAIvB,UAGb,IAAawB,WAAyBC,EAAiBvB,aAE3B,iBAAfuB,oCAIiBC,QAAMD,EAAYvB,mBAAxCyB,OACDA,EAAcC,SACX,IAAI5F,0CAC4B6F,KAAKC,UACvCH,EAAc9E,MACd,KACA,QAaD4E,EAAU,WACP,IAAIzF,MAAM,oCAGbuD,EAAOI,UAAU8B,EAAY,QAAQM,SAAS,8BAC3C,IAAI/F,MAAM,mDAGbyF,EAAU,wBACP,IAAIzF,MAAM,iDAGbyF,EAAU,aACP,IAAIzF,MAAM,qCAIduD,EAAOI,UAAU8B,EAAY,gBAAgBV,OAAS,QAClD,IAAI/E,MAAM,wDAIbyF,EAAU,mBACP,IAAIzF,MAAM,2CAGd,iBAAkByF,IACfL,EAAUY,KAAKP,EAAWQ,oBACvB,IAAIjG,8CACgCyF,EAAWQ,iBAMrD1C,EAAOI,UAAU8B,EAAY,UAAUV,OAAS,QAC5C,IAAI/E,MAAM,iDAKd,WAAYyF,EAAY,KACpBX,EAASQ,EAAOG,EAAWX,YAC5BA,QACG,IAAI9E,sCAEP8E,EAAOiB,SAAS,WACb,IAAI/F,oCAAoC8E,MAI9C,qBAAsBW,EAAY,KAC/BA,EAAWS,iBAAiBlC,SACzB,IAAIhE,MAAM,8CAEbyF,EAAWS,iBAAiBC,WACzB,IAAInG,MAAM,8CAMpBuD,EAAOI,UAAU8B,EAAY,YAAYW,SAAQ,SAACC,OAC1CC,EAAahB,EAAOe,MACtBC,IAAeA,EAAWP,SAAS,WAC/B,IAAI/F,sCAAsCqG,MAMlD,mBAAoBZ,IACnBL,EAAUY,KAAKP,EAAWc,sBAErB,IAAIvG,gDACkCyF,EAAWc,uDC1H9CC,EAAoB,SAACC,OAclBlD,EAAOI,UAAU8C,EAAc,QAGlCV,SAAS,gCACZ,IAAI/F,MAAM,kDCiCP0G,WAA0BC,WAC7BlB,EAAekB,EAAflB,mBAEDA,QACG,IAAIxF,UAAU,sEAhDO0G,WACvBlB,EAA4CkB,EAA5ClB,WAAYmB,EAAgCD,EAAhCC,mCAGdpB,EAAgBC,EAH8BkB,EAAnBzC,qCAO/BuB,EAAWS,kBACoB,mBAAxBS,EAAQC,kBAET,IAAI3G,UACR,6FAME4G,EACJF,EAAQE,SACR,IAAIpC,EAA0B,CAC5BhB,WAJmBkD,EAAflD,oCAOaqD,SAAYrB,KAC/BoB,QAAAA,GACGF,oBAFCrF,OAMDA,EAAOyF,gBACHzF,sBAGLmE,EAAWS,wCACeU,EAAYD,sBAAxCrF,EAAO0F,eACF1F,EAAO0F,aAAaD,WACvBzF,EAAOyF,UAAW,oDAIfzF,KAAAA,2CASE2F,CAAkBN,GACzB,MAAO9F,0BACA,CACLkG,UAAU,EACVG,QAAS,CAAC,CAAEzB,WAAAA,EAAYsB,UAAU,EAAOlG,MAAAA,IACzCA,MAAAA,yCC1DOsG,+BAKJ,KAJPC,IAAAA,qBACApD,IAAAA,GACAqD,IAAAA,OACAnD,IAAAA,2CAcIF,IACFyC,EAAazC,GAAKA,GAEhBqD,IACFZ,EAAaY,OAASA,GAGxBb,EAAkBC,GAEXA,GArBDA,EAAoB,YACZ,CAAC3D,EAAUE,4BACvBmD,KAAM,CAAC,2CAELiB,oBAMFX,EAAaW,qBAAuBE,GAL9BA,EAAc,GAAGC,OAAOH,KTsJlC,SAAuBI,EAAQ/E,EAAMiD,GACpC,GAAuC,mBAA5B8B,EAAOnF,GAAiC,CAClD,IAA0CoF,EAAMzF,EAAM0F,EAAlDnF,EAAWiF,EAAOnF,KAwBtB,GAvBA,SAASsF,EAAOrG,GACf,IACC,OAASmG,EAAOlF,EAASqF,QAAQC,MAEhC,IADAvG,EAASmB,EAAKgF,EAAK1F,SACLT,EAAOH,KAAM,CAC1B,IAAIgB,EAAeb,GAIlB,YADAA,EAAOH,KAAKwG,EAAQD,IAAWA,EAAShG,EAAQO,KAAK,KAAMD,EAAO,IAAIf,EAAS,KAF/EK,EAASA,EAAOK,EAOfK,EACHN,EAAQM,EAAM,EAAGV,GAEjBU,EAAOV,EAEP,MAAOM,GACRF,EAAQM,IAASA,EAAO,IAAIf,GAAU,EAAGW,IAG3C+F,GACIpF,EAASuF,OAAQ,CACpB,IAAIC,EAAS,SAAShG,GACrB,IACM0F,EAAKI,MACTtF,EAASuF,SAET,MAAMlG,IAER,OAAOG,GAER,GAAIC,GAAQA,EAAKb,KAChB,OAAOa,EAAKb,KAAK4G,GAAQ,SAASnG,GACjC,MAAMmG,EAAOnG,MAGfmG,IAED,OAAO/F,EAGR,KAAM,WAAYwF,GACjB,MAAM,IAAIvH,UAAU,0BAIrB,IADA,IAAI+H,EAAS,GACJC,EAAI,EAAGA,EAAIT,EAAOzC,OAAQkD,IAClCD,EAAOE,KAAKV,EAAOS,IAEpB,OA5GD,SAAuBE,EAAO1F,EAAMiD,GACnC,IAAY1D,EAAM0F,EAAdO,GAAK,EAwBT,OAvBA,SAASN,EAAOrG,GACf,IACC,OAAS2G,EAAIE,EAAMpD,QAElB,IADAzD,EAASmB,EAAKwF,KACA3G,EAAOH,KAAM,CAC1B,IAAIgB,EAAeb,GAIlB,YADAA,EAAOH,KAAKwG,EAAQD,IAAWA,EAAShG,EAAQO,KAAK,KAAMD,EAAO,IAAIf,EAAS,KAF/EK,EAASA,EAAOK,EAOfK,EACHN,EAAQM,EAAM,EAAGV,GAEjBU,EAAOV,EAEP,MAAOM,GACRF,EAAQM,IAASA,EAAO,IAAIf,GAAU,EAAGW,IAG3C+F,GACO3F,EAmFAoG,CAAOJ,GAAQ,SAASC,GAAK,OAAOxF,EAAKuF,EAAOC,QS1M3BX,YAAd7B,0BACHD,EAAgBC,EAAYvB,oLChBZyC,WAClBlB,EAAsCkB,EAAtClB,WAAYb,EAA0B+B,EAA1B/B,MAAOV,EAAmByC,EAAnBzC,mBAGtBuB,QACG,IAAIxF,UAAU,0EAEhBuF,EAAgBC,EAAYvB,yBAE7BA,QACG,IAAIjE,UAAU,2DAGjB2E,QACG,IAAI3E,UAAU,kDAKjB2E,EAAMX,yBACH,IAAIhE,UAAU,wDAGhB4G,EAAUF,EAAQE,SAAW,IAAIpC,SAEhC4D,OAAK5C,KAAcoB,QAAAA,GAAYF,8EFqGXA,WACtBA,EAAQzC,qBACL,IAAIjE,UACR,6DAGIwG,EAAiBE,EAAjBF,qBAEDA,QACG,IAAIxG,UACR,wEAvE2B0G,WAS7B2B,kBAwBAC,QAEK,CAAExB,SAAAA,EAAUG,QAAS,CAACT,GAAe6B,kBAAAA,OAGtC7E,EAAkCkD,EAAlClD,WAAYyB,EAAsByB,EAAtBzB,OAAQD,EAAc0B,EAAd1B,cACvB0B,EAAQ6B,sBAAwBvD,QAC7B,IAAIjF,MACR,uEAIE6G,EACJF,EAAQ6B,qBACR,IAAIxD,EAA2B,CAAEvB,WAAAA,EAAYyB,OAAAA,EAAQD,UAAAA,2BAEtB6B,SAAYL,KAC3CI,QAAAA,GACGF,oBAFC8B,SAKC,CACLA,mBAAAA,EACA1B,SAAUA,GAAY0B,EAAmB1B,SACzCuB,kBAAAA,EACAzH,MAAO4H,EAAmB5H,WAzDpB4F,EAAuCE,EAAvCF,aAAc8B,EAAyB5B,EAAzB4B,qBAEtB/B,EAAkBC,OAOdM,GAAW,EACTO,EAAc/D,EAAOI,UAAU8C,EAAc,wCAC/Ca,EAAYvC,OAAS,yBAEG2D,QAAQC,IAChCrB,EAAYsB,KAAI,SAACnD,UACRiB,KAAmBjB,WAAAA,GAAekB,4BAI7C2B,GANAA,KAMsCM,KAAI,SAACC,EAASZ,UAClDY,EAAGC,aAAexB,EAAYW,GAAGjE,GAC1B6E,MAGwCE,OAC/C,SAACC,UAAWA,EAAEjC,cAGdA,GAAW,4FA6CNkC,CAAoBtC,GAC3B,MAAO9F,0BACA,CACLkG,UAAU,EACVG,QAAS,CAAC,CAAET,aAAAA,EAAcM,UAAU,EAAOlG,MAAAA,IAC3CA,MAAAA,wFChHiC8F,YAAAA,IAAAA,EAAe,YAC5CF,EAAoDE,EAApDF,aAAiCvC,EAAmByC,EAAnBzC,eACnC2C,EACJF,EAAQE,SACR,IAAI7B,EAA2B,CAC7BE,OAJwDyB,EAAtCzB,OAKlBD,UALwD0B,EAA9B1B,gBAQzBf,QACG,IAAIjE,UAAU,8EAGfoI,OAAK5B,KAAgBI,QAAAA,GAAYF,qFEjCxCuC,EACAC,EACAjF,eAEkCnE,IAA9BmJ,EAAmBpE,aACf,IAAI9E,MAAM,uDAIyBD,IAAzCmJ,EAAmBE,wBACyBrJ,IAA5CmJ,EAAmBE,kBAAkBpF,SAE/B,IAAIhE,MAAM,oDAGd8E,GA5BYuE,EA4BMH,EAAmBpE,OA3BrCwE,MAAMC,QAAQF,IAIC,iBAATA,GAAqC,mBAATA,GAC3B,OAATA,EAwBEH,EAAmBpE,OADnBoE,EAAmBpE,OAAOd,IAG1BwF,EAAUN,EAAmBE,kBAAkBpF,0BAE7CwB,EAAgB0D,EAAoBhF,yBAEpCuF,EAAyB,CAC7BC,IAAK5E,EACL6E,IAAKH,EACLI,GAAIV,UAGFA,EAAmBlF,KACrByF,EAAQI,IAAMX,EAAmBlF,IAG/BkF,EAAmBjD,eACrBwD,EAAQK,IAAMC,EAAOb,EAAmBjD,cAAc+D,QAGpDd,EAAmB3C,iBACrBkD,EAAQQ,IAAMF,EAAOb,EAAmB3C,gBAAgByD,QAInDb,EAAOd,KAAKoB,EADJ,yCAtDA,IAACJ,+BCChB/B,EACAD,EACArD,8BAEiBkG,EAA6B,CAC5C9C,qBAAsBE,EACtBD,OAAAA,EACArD,GAAAA,oBAHImG,OAMAV,EAAsC,CAC1CC,IAAKrC,EACLsC,IAAKtC,EACL8C,GAAIA,UAGFA,EAAGnG,KACLyF,EAAQI,IAAMM,EAAGnG,IAEZyF,2DAGwB,SAC/BU,EACAxD,EACAwC,UAEIxC,EAAQ1B,YACVkF,EAAGC,MAAQzD,EAAQ1B,WAEjB0B,EAAQzB,SACViF,EAAGE,IAAM1D,EAAQzB,QAGZiE,EAAOd,KAAK8B,EADJ,YCtCK,SAACG,EAAaC,UAC3BA,EAASC,OAAOF"}