import { Ed25519KeyPair, EdDSA, keyUtils } from '@transmute/did-key-ed25519';
export * from '@transmute/did-key-ed25519';
import jsonld from 'jsonld';
import crypto from 'crypto';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var _require = /*#__PURE__*/require('security-context'),
    securityConstants = _require.constants;

var constants = {
  // leave commented out, changing this will break compatability
  // with digital bazaar
  // SECURITY_CONTEXT_URL: 'https://w3id.org/security/v3',
  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,
  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',
  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature'
};

var sha256 = function sha256(data) {
  var h = crypto.createHash('sha256');
  h.update(data);
  return h.digest();
};

var Ed25519Signature2018 = /*#__PURE__*/function () {
  function Ed25519Signature2018(options) {
    var _this = this,
        _this2 = this;

    if (options === void 0) {
      options = {};
    }

    this.useNativeCanonize = false;
    this.type = 'Ed25519Signature2018';
    this.signer = options.signer;
    this.date = options.date;

    if (options.key) {
      this.key = options.key;
      this.verificationMethod = this.key.id;
      this.signer = {
        sign: function (_ref) {
          var data = _ref.data;

          try {
            var header = {
              alg: 'EdDSA',
              b64: false,
              crit: ['b64']
            };
            var payload = Buffer.from(data);
            return Promise.resolve(_this.key.toJsonWebKeyPair(true)).then(function (_ref2) {
              var privateKeyJwk = _ref2.privateKeyJwk;
              return Promise.resolve(EdDSA.signDetached(payload, privateKeyJwk, header));
            });
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
      this.verifier = {
        verify: function (_ref3) {
          var data = _ref3.data,
              signature = _ref3.signature;

          try {
            var verified = false;

            var _temp2 = _catch(function () {
              return Promise.resolve(EdDSA.verifyDetached(signature, data, keyUtils.publicKeyJwkFromPublicKeyBase58(_this2.key.publicKeyBase58))).then(function (_EdDSA$verifyDetached) {
                verified = _EdDSA$verifyDetached;
              });
            }, function (e) {
              console.error('An error occurred when verifying signature: ', e);
            });

            return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {
              return verified;
            }) : verified);
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
    }
  }

  var _proto = Ed25519Signature2018.prototype;

  _proto.canonize = function canonize(input, _ref4) {
    var documentLoader = _ref4.documentLoader,
        expansionMap = _ref4.expansionMap,
        skipExpansion = _ref4.skipExpansion;

    try {
      var _this4 = this;

      return Promise.resolve(jsonld.canonize(input, {
        algorithm: 'URDNA2015',
        format: 'application/n-quads',
        documentLoader: documentLoader,
        expansionMap: expansionMap,
        skipExpansion: skipExpansion,
        useNative: _this4.useNativeCanonize
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.canonizeProof = function canonizeProof(proof, _ref5) {
    var documentLoader = _ref5.documentLoader,
        expansionMap = _ref5.expansionMap;

    try {
      var _this6 = this;

      // `jws`,`signatureValue`,`proofValue` must not be included in the proof
      // options
      proof = _extends({}, proof);
      delete proof.jws;
      delete proof.signatureValue;
      delete proof.proofValue;
      return Promise.resolve(_this6.canonize(proof, {
        documentLoader: documentLoader,
        expansionMap: expansionMap,
        skipExpansion: false
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.createVerifyData = function createVerifyData(_ref6) {
    var document = _ref6.document,
        proof = _ref6.proof,
        documentLoader = _ref6.documentLoader,
        expansionMap = _ref6.expansionMap;

    try {
      var _this8 = this;

      // concatenate hash of c14n proof options and hash of c14n document
      return Promise.resolve(_this8.canonizeProof(proof, {
        documentLoader: documentLoader,
        expansionMap: expansionMap
      })).then(function (c14nProofOptions) {
        return Promise.resolve(_this8.canonize(document, {
          documentLoader: documentLoader,
          expansionMap: expansionMap
        })).then(function (c14nDocument) {
          return Buffer.concat([sha256(c14nProofOptions), sha256(c14nDocument)]);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.matchProof = function matchProof(_ref7) {
    var proof = _ref7.proof;

    try {
      var _this10 = this;

      return Promise.resolve(proof.type === _this10.type);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.updateProof = function updateProof(_ref8) {
    var proof = _ref8.proof;
    // extending classes may do more
    return Promise.resolve(proof);
  };

  _proto.sign = function sign(_ref9) {
    var verifyData = _ref9.verifyData,
        proof = _ref9.proof;

    try {
      var _this12 = this;

      if (!(_this12.signer && typeof _this12.signer.sign === 'function')) {
        throw new Error('A signer API has not been specified.');
      }

      return Promise.resolve(_this12.signer.sign({
        data: verifyData
      })).then(function (detachedJws) {
        proof.jws = detachedJws;
        return proof;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.createProof = function createProof(_ref10) {
    var document = _ref10.document,
        purpose = _ref10.purpose,
        documentLoader = _ref10.documentLoader,
        expansionMap = _ref10.expansionMap,
        compactProof = _ref10.compactProof;

    try {
      var _temp5 = function _temp5() {
        // ensure proof type is set
        proof.type = _this14.type; // set default `now` date if not given in `proof` or `options`

        var date = _this14.date;

        if (proof.created === undefined && date === undefined) {
          date = new Date();
        } // ensure date is in string format


        if (date !== undefined && typeof date !== 'string') {
          date = new Date(date).toISOString();
        } // add API overrides


        if (date !== undefined) {
          proof.created = date;
        } // `verificationMethod` is for newer suites, `creator` for legacy


        if (_this14.verificationMethod !== undefined) {
          proof.verificationMethod = _this14.verificationMethod;
        }

        if (_this14.creator !== undefined) {
          proof.creator = _this14.creator;
        } // add any extensions to proof (mostly for legacy support)


        return Promise.resolve(_this14.updateProof({
          document: document,
          proof: proof,
          purpose: purpose,
          documentLoader: documentLoader,
          expansionMap: expansionMap,
          compactProof: compactProof
        })).then(function (_this13$updateProof) {
          proof = _this13$updateProof;
          // allow purpose to update the proof; the `proof` is in the
          // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must
          // ensure any added fields are also represented in that same `@context`
          return Promise.resolve(purpose.update(proof, {
            document: document,
            suite: _this14,
            documentLoader: documentLoader,
            expansionMap: expansionMap
          })).then(function (_purpose$update) {
            proof = _purpose$update;
            // create data to sign
            return Promise.resolve(_this14.createVerifyData({
              document: document,
              proof: proof,
              documentLoader: documentLoader,
              expansionMap: expansionMap,
              compactProof: compactProof
            })).then(function (verifyData) {
              // sign data
              return Promise.resolve(_this14.sign({
                verifyData: verifyData,
                document: document,
                proof: proof,
                documentLoader: documentLoader,
                expansionMap: expansionMap
              })).then(function (_this13$sign) {
                proof = _this13$sign;
                return proof;
              });
            });
          });
        });
      };

      var _this14 = this;

      // build proof (currently known as `signature options` in spec)
      var proof;

      var _temp6 = function () {
        if (_this14.proof) {
          // use proof JSON-LD document passed to API
          return Promise.resolve(jsonld.compact(_this14.proof, constants.SECURITY_CONTEXT_URL, {
            documentLoader: documentLoader,
            expansionMap: expansionMap,
            compactToRelative: false
          })).then(function (_jsonld$compact) {
            proof = _jsonld$compact;
          });
        } else {
          // create proof JSON-LD document
          proof = {
            '@context': constants.SECURITY_CONTEXT_URL
          };
        }
      }();

      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getVerificationMethod = function getVerificationMethod(_ref11) {
    var proof = _ref11.proof,
        documentLoader = _ref11.documentLoader;

    try {
      var verificationMethod = proof.verificationMethod;

      if (!verificationMethod) {
        // backwards compatibility support for `creator`
        var creator = proof.creator;
        verificationMethod = creator;
      }

      if (typeof verificationMethod === 'object') {
        verificationMethod = verificationMethod.id;
      }

      if (!verificationMethod) {
        throw new Error('No "verificationMethod" or "creator" found in proof.');
      } // Note: `expansionMap` is intentionally not passed; we can safely drop
      // properties here and must allow for it


      return Promise.resolve(jsonld.frame(verificationMethod, {
        // '@context': constants.SECURITY_CONTEXT_URL,
        '@context': constants.SECURITY_CONTEXT_URL,
        '@embed': '@always',
        id: verificationMethod
      }, {
        documentLoader: documentLoader,
        compactToRelative: false
      })).then(function (framed) {
        if (!framed) {
          throw new Error("Verification method " + verificationMethod + " not found.");
        } // ensure verification method has not been revoked


        if (framed.revoked !== undefined) {
          throw new Error('The verification method has been revoked.');
        }

        return framed;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.verifySignature = function verifySignature(_ref12) {
    var verifyData = _ref12.verifyData,
        verificationMethod = _ref12.verificationMethod,
        proof = _ref12.proof;

    try {
      var _temp9 = function _temp9() {
        return verifier.verify({
          data: verifyData,
          signature: proof.jws
        });
      };

      var _this16 = this;

      var verifier = _this16.verifier;

      var _temp10 = function () {
        if (!verifier) {
          return Promise.resolve(Ed25519KeyPair.from(verificationMethod)).then(function (key) {
            // this suite relies on detached JWS....
            // so we need to make sure thats the signature format we are verifying.
            verifier = {
              verify: function (_ref13) {
                var data = _ref13.data,
                    signature = _ref13.signature;

                try {
                  var verified = false;
                  return Promise.resolve(key.toJsonWebKeyPair(false)).then(function (_ref14) {
                    var publicKeyJwk = _ref14.publicKeyJwk;

                    var _temp11 = _catch(function () {
                      return Promise.resolve(EdDSA.verifyDetached(signature, data, publicKeyJwk)).then(function (_EdDSA$verifyDetached2) {
                        verified = _EdDSA$verifyDetached2;
                      });
                    }, function (e) {
                      console.error('An error occurred when verifying signature: ', e);
                    });

                    return _temp11 && _temp11.then ? _temp11.then(function () {
                      return verified;
                    }) : verified;
                  });
                } catch (e) {
                  return Promise.reject(e);
                }
              }
            };
          });
        }
      }();

      return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(_temp9) : _temp9(_temp10));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.verifyProof = function verifyProof(_ref15) {
    var proof = _ref15.proof,
        document = _ref15.document,
        purpose = _ref15.purpose,
        documentLoader = _ref15.documentLoader,
        expansionMap = _ref15.expansionMap,
        compactProof = _ref15.compactProof;

    try {
      var _this18 = this;

      return Promise.resolve(_catch(function () {
        // create data to verify
        return Promise.resolve(_this18.createVerifyData({
          document: document,
          proof: proof,
          documentLoader: documentLoader,
          expansionMap: expansionMap,
          compactProof: compactProof
        })).then(function (verifyData) {
          // fetch verification method
          return Promise.resolve(_this18.getVerificationMethod({
            proof: proof,
            document: document,
            documentLoader: documentLoader,
            expansionMap: expansionMap
          })).then(function (verificationMethod) {
            // verify signature on data
            return Promise.resolve(_this18.verifySignature({
              verifyData: verifyData,
              verificationMethod: verificationMethod,
              document: document,
              proof: proof,
              documentLoader: documentLoader,
              expansionMap: expansionMap
            })).then(function (verified) {
              if (!verified) {
                throw new Error('Invalid signature.');
              } // ensure proof was performed for a valid purpose


              return Promise.resolve(purpose.validate(proof, {
                document: document,
                suite: _this18,
                verificationMethod: verificationMethod,
                documentLoader: documentLoader,
                expansionMap: expansionMap
              })).then(function (purposeResult) {
                // console.log(purposeResult);
                if (!purposeResult.valid) {
                  throw purposeResult.error;
                }

                return {
                  verified: true,
                  purposeResult: purposeResult
                };
              });
            });
          });
        });
      }, function (error) {
        return {
          verified: false,
          error: error
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Ed25519Signature2018;
}();

export { Ed25519Signature2018 };
//# sourceMappingURL=ed25519-signature-2018.esm.js.map
