{"version":3,"file":"linked-data-proof.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/constants.ts","../src/strictExpansionMap.ts","../src/getTypeInfo.ts","../src/ProofSet.ts","../src/sign.ts","../src/VerificationError.ts","../src/verify.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","const { constants: securityConstants } = require('security-context');\n\nexport default {\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V3_URL: 'https://w3id.org/security/v3-unstable',\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature',\n};\n","// strict expansion map disallows dropping properties when expanding by default\nexport default (info: any) => {\n  if (info.unmappedProperty) {\n    throw new Error(\n      `The property \"${info.unmappedProperty}\" in the input was not defined in the context.`\n    );\n  }\n};\n","import jsonld from 'jsonld';\n\nimport { IGetTypeInfoOptions } from './types';\n\nconst getTypeInfo = async ({\n  document,\n  documentLoader,\n  expansionMap,\n}: IGetTypeInfoOptions) => {\n  // determine `@type` alias, if any\n  const ctx = jsonld.getValues(document, '@context');\n  const compacted = await jsonld.compact({ '@type': '_:b0' }, ctx, {\n    documentLoader,\n    expansionMap,\n  });\n  delete compacted['@context'];\n  const alias = Object.keys(compacted)[0];\n\n  // optimize: expand only `@type` and `type` values\n  const toExpand: any = { '@context': ctx };\n  toExpand['@type'] = jsonld\n    .getValues(document, '@type')\n    .concat(jsonld.getValues(document, alias));\n  const expanded =\n    (await jsonld.expand(toExpand, { documentLoader, expansionMap }))[0] || {};\n  return { types: jsonld.getValues(expanded, '@type'), alias };\n};\n\nexport default getTypeInfo;\n","import jsonld from 'jsonld';\nimport { serializeError } from 'serialize-error';\nimport constants from './constants';\nimport strictExpansionMap from './strictExpansionMap';\nimport getTypeInfo from './getTypeInfo';\n\nimport { IProofSetAddOptions } from './types';\n\nexport class ProofSet {\n  async add(\n    document: any,\n    {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof = true,\n    }: IProofSetAddOptions = { compactProof: true }\n  ) {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!documentLoader) {\n      throw new TypeError('\"options.documentLoader\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if (suite.legacy) {\n      throw new TypeError(`Legacy suites are no longer supported.`);\n    }\n\n    if (expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    if (typeof document === 'string') {\n      // fetch document\n      document = await documentLoader(document);\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    let input;\n    if (compactProof) {\n      // cannot assume security context terms, so do full compaction\n      input = await jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false,\n      });\n    } else {\n      // TODO: optimize to modify document in place to maximize optimization\n\n      // shallow copy document to allow removal of existing proofs\n      input = { ...document };\n    }\n\n    // save but exclude any existing proof(s)\n    const proofProperty = suite.legacy ? 'signature' : 'proof';\n    //const existingProofs = input[proofProperty];\n    delete input[proofProperty];\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof,\n    });\n\n    if (compactProof) {\n      // compact proof to match document's context\n      let expandedProof;\n      if (suite.legacy) {\n        expandedProof = {\n          [constants.SECURITY_SIGNATURE_URL]: proof,\n        };\n      } else {\n        expandedProof = {\n          [constants.SECURITY_PROOF_URL]: { '@graph': proof },\n        };\n      }\n      // account for type-scoped `proof` definition by getting document types\n      const { types, alias } = await getTypeInfo({\n        document,\n        documentLoader,\n        expansionMap,\n      });\n      expandedProof['@type'] = types;\n      const ctx = jsonld.getValues(document, '@context');\n      const compactProof = await jsonld.compact(expandedProof, ctx, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false,\n      });\n      delete compactProof[alias];\n      delete compactProof['@context'];\n\n      // add proof to document\n      const key = Object.keys(compactProof)[0];\n      jsonld.addValue(document, key, compactProof[key]);\n    } else {\n      // in-place restore any existing proofs\n      /*if(existingProofs) {\n            document[proofProperty] = existingProofs;\n          }*/\n      // add new proof\n      delete proof['@context'];\n      jsonld.addValue(document, proofProperty, proof);\n    }\n\n    return document;\n  }\n\n  private _getProofs = async ({\n    document,\n    legacy,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: any) => {\n    // handle document preprocessing to find proofs\n    const proofProperty = legacy ? 'signature' : 'proof';\n    let proofSet;\n\n    if (compactProof) {\n      // if we must compact the proof(s) then we must first compact the input\n      // document to find the proof(s)\n      document = await jsonld.compact(\n        document,\n        constants.SECURITY_CONTEXT_URL,\n        { documentLoader, expansionMap, compactToRelative: false }\n      );\n    }\n    proofSet = jsonld.getValues(document, proofProperty);\n    delete document[proofProperty];\n\n    if (proofSet.length === 0) {\n      // no possible matches\n      throw new Error('No matching proofs found in the given document.');\n    }\n\n    // TODO: consider in-place editing to optimize\n\n    // shallow copy proofs and add SECURITY_CONTEXT_URL\n    proofSet = proofSet.map((proof: any) => ({\n      '@context': constants.SECURITY_CONTEXT_URL,\n      ...proof,\n    }));\n\n    return { proofSet, document };\n  };\n\n  private _verify = async ({\n    document,\n    suites,\n    proofSet,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: any) => {\n    // filter out matching proofs\n    const result = await Promise.all(\n      proofSet.map((proof: any) =>\n        purpose.match(proof, { document, documentLoader, expansionMap })\n      )\n    );\n    const matches = proofSet.filter((_value: any, index: any) => result[index]);\n    if (matches.length === 0) {\n      // no matches, nothing to verify\n      return [];\n    }\n\n    // verify each matching proof\n    return (\n      await Promise.all(\n        matches.map(async (proof: any) => {\n          for (const s of suites) {\n            if (\n              await s.matchProof({\n                proof,\n                document,\n                documentLoader,\n                expansionMap,\n              })\n            ) {\n              return s\n                .verifyProof({\n                  proof,\n                  document,\n                  purpose,\n                  documentLoader,\n                  expansionMap,\n                  compactProof,\n                })\n                .catch((error: any) => ({ verified: false, error }));\n            }\n          }\n        })\n      )\n    )\n      .map((r: any, i) => {\n        if (!r) {\n          return null;\n        }\n        if (r.error) {\n          this._addToJSON(r.error);\n        }\n        return { proof: matches[i], ...r };\n      })\n      .filter((r) => r);\n  };\n\n  private _addToJSON = (error: any) => {\n    Object.defineProperty(error, 'toJSON', {\n      value: function() {\n        return serializeError(this);\n      },\n      configurable: true,\n      writable: true,\n    });\n  };\n\n  public verify = async (\n    document: any,\n    {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof = true,\n    }: any = {}\n  ) => {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if (suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    const legacy = suites.some((s) => s.legacy);\n    if (legacy) {\n      throw new TypeError(`Legacy suites are no longer supported.`);\n    }\n\n    if (!documentLoader) {\n      throw new TypeError('\"options.documentLoader\" is required.');\n    }\n    if (expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    try {\n      if (typeof document === 'string') {\n        // fetch document\n        document = await documentLoader(document);\n      } else {\n        // TODO: consider in-place editing to optimize when `compactProof`\n        // is `false`\n\n        // shallow copy to allow for removal of proof set prior to canonize\n        document = { ...document };\n      }\n\n      // get proofs from document\n      const { proofSet, document: doc } = await this._getProofs({\n        document,\n        legacy,\n        documentLoader,\n        expansionMap,\n        compactProof,\n      });\n\n      document = doc;\n\n      // verify proofs\n      const results = await this._verify({\n        document,\n        suites,\n        proofSet,\n        purpose,\n        documentLoader,\n        expansionMap,\n        compactProof,\n      });\n\n      if (results.length === 0) {\n        throw new Error(\n          'Could not verify any proofs; no proofs matched the required ' +\n            'suite and purpose.'\n        );\n      }\n\n      // combine results\n      const verified = results.some((r) => r.verified);\n      if (!verified) {\n        const errors = [].concat(\n          ...results.filter((r) => r.error).map((r) => r.error)\n        );\n        const result: any = { verified, results };\n        if (errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return { verified, results };\n    } catch (error) {\n      this._addToJSON(error);\n      return { verified: false, error };\n    }\n  };\n}\n","import { ProofSet } from './ProofSet';\n\nimport { ISignOptions } from './types';\n\nexport const sign = async (\n  document: any,\n  {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: ISignOptions = {\n    compactProof: true,\n  }\n) => {\n  try {\n    return await new ProofSet().add(document, {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof,\n    });\n  } catch (e) {\n    if (!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {\n        details: { url },\n      } = e;\n      const err: any = new Error(\n        `A URL \"${url}\" could not be fetched;` +\n          `you need to pass \"documentLoader\" or resolve the URL before calling \"sign\".`\n      );\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n","export class VerificationError extends Error {\n  public errors: any[];\n  constructor(errors: any) {\n    super('Verification error(s).');\n\n    this.name = 'VerificationError';\n    this.errors = [].concat(errors);\n  }\n}\n","import { ProofSet } from './ProofSet';\nimport { VerificationError } from './VerificationError';\nimport { IVerifyOptions } from './types';\nexport const verify = async (\n  document: any,\n  {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: IVerifyOptions = {}\n) => {\n  const result = await new ProofSet().verify(document, {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  });\n  const { error } = result;\n  if (error) {\n    if (!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {\n        details: { url },\n      } = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n          '\"documentLoader\" or resolve the URL before calling \"verify\".'\n      );\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n"],"names":["require","securityConstants","constants","SECURITY_CONTEXT_URL","SECURITY_CONTEXT_V2_URL","SECURITY_CONTEXT_V1_URL","SECURITY_CONTEXT_V3_URL","SECURITY_PROOF_URL","SECURITY_SIGNATURE_URL","info","unmappedProperty","Error","getTypeInfo","document","documentLoader","expansionMap","ctx","jsonld","getValues","compact","compacted","alias","Object","keys","toExpand","concat","expand","expanded","types","ProofSet","legacy","compactProof","proofSet","proofProperty","length","map","proof","compactToRelative","suites","purpose","Promise","all","match","result","matches","filter","_value","index","s","matchProof","verifyProof","error","verified","r","i","_addToJSON","defineProperty","value","serializeError","configurable","writable","suite","TypeError","Array","isArray","some","strictExpansionMap","_getProofs","doc","_verify","results","errors","add","input","createProof","expandedProof","key","addValue","sign","e","name","url","details","err","cause","VerificationError","verify","urlError"],"mappings":"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"}