'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var jsonld = _interopDefault(require('jsonld'));
var serializeError = require('serialize-error');

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)
function _forTo(array, body, check) {
	var i = -1, pact, reject;
	function _cycle(result) {
		try {
			while (++i < array.length && (!check || !check())) {
				result = body(i);
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
						return;
					}
				}
			}
			if (pact) {
				_settle(pact, 1, result);
			} else {
				pact = result;
			}
		} catch (e) {
			_settle(pact || (pact = new _Pact()), 2, e);
		}
	}
	_cycle();
	return pact;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

// Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy
function _forOf(target, body, check) {
	if (typeof target[_iteratorSymbol] === "function") {
		var iterator = target[_iteratorSymbol](), step, pact, reject;
		function _cycle(result) {
			try {
				while (!(step = iterator.next()).done && (!check || !check())) {
					result = body(step.value);
					if (result && result.then) {
						if (_isSettledPact(result)) {
							result = result.v;
						} else {
							result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
							return;
						}
					}
				}
				if (pact) {
					_settle(pact, 1, result);
				} else {
					pact = result;
				}
			} catch (e) {
				_settle(pact || (pact = new _Pact()), 2, e);
			}
		}
		_cycle();
		if (iterator.return) {
			var _fixup = function(value) {
				try {
					if (!step.done) {
						iterator.return();
					}
				} catch(e) {
				}
				return value;
			};
			if (pact && pact.then) {
				return pact.then(_fixup, function(e) {
					throw _fixup(e);
				});
			}
			_fixup();
		}
		return pact;
	}
	// No support for Symbol.iterator
	if (!("length" in target)) {
		throw new TypeError("Object is not iterable");
	}
	// Handle live collections properly
	var values = [];
	for (var i = 0; i < target.length; i++) {
		values.push(target[i]);
	}
	return _forTo(values, function(i) { return body(values[i]); }, check);
}

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

var _require = /*#__PURE__*/require('security-context'),
    securityConstants = _require.constants;

var constants = {
  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,
  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
  SECURITY_CONTEXT_V3_URL: 'https://w3id.org/security/v3-unstable',
  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',
  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature'
};

// strict expansion map disallows dropping properties when expanding by default
var strictExpansionMap = (function (info) {
  if (info.unmappedProperty) {
    throw new Error("The property \"" + info.unmappedProperty + "\" in the input was not defined in the context.");
  }
});

var getTypeInfo = function getTypeInfo(_ref) {
  var document = _ref.document,
      documentLoader = _ref.documentLoader,
      expansionMap = _ref.expansionMap;

  try {
    // determine `@type` alias, if any
    var ctx = jsonld.getValues(document, '@context');
    return Promise.resolve(jsonld.compact({
      '@type': '_:b0'
    }, ctx, {
      documentLoader: documentLoader,
      expansionMap: expansionMap
    })).then(function (compacted) {
      delete compacted['@context'];
      var alias = Object.keys(compacted)[0]; // optimize: expand only `@type` and `type` values

      var toExpand = {
        '@context': ctx
      };
      toExpand['@type'] = jsonld.getValues(document, '@type').concat(jsonld.getValues(document, alias));
      return Promise.resolve(jsonld.expand(toExpand, {
        documentLoader: documentLoader,
        expansionMap: expansionMap
      })).then(function (_jsonld$expand) {
        var expanded = _jsonld$expand[0] || {};
        return {
          types: jsonld.getValues(expanded, '@type'),
          alias: alias
        };
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var ProofSet = /*#__PURE__*/function () {
  function ProofSet() {
    var _this = this,
        _this2 = this;

    this._getProofs = function (_ref) {
      var document = _ref.document,
          legacy = _ref.legacy,
          documentLoader = _ref.documentLoader,
          expansionMap = _ref.expansionMap,
          compactProof = _ref.compactProof;

      try {
        var _temp3 = function _temp3() {
          proofSet = jsonld.getValues(document, proofProperty);
          delete document[proofProperty];

          if (proofSet.length === 0) {
            // no possible matches
            throw new Error('No matching proofs found in the given document.');
          } // TODO: consider in-place editing to optimize
          // shallow copy proofs and add SECURITY_CONTEXT_URL


          proofSet = proofSet.map(function (proof) {
            return _extends({
              '@context': constants.SECURITY_CONTEXT_URL
            }, proof);
          });
          return {
            proofSet: proofSet,
            document: document
          };
        };

        // handle document preprocessing to find proofs
        var proofProperty = legacy ? 'signature' : 'proof';
        var proofSet;

        var _temp4 = function () {
          if (compactProof) {
            // if we must compact the proof(s) then we must first compact the input
            // document to find the proof(s)
            return Promise.resolve(jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {
              documentLoader: documentLoader,
              expansionMap: expansionMap,
              compactToRelative: false
            })).then(function (_jsonld$compact) {
              document = _jsonld$compact;
            });
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    this._verify = function (_ref2) {
      var document = _ref2.document,
          suites = _ref2.suites,
          proofSet = _ref2.proofSet,
          purpose = _ref2.purpose,
          documentLoader = _ref2.documentLoader,
          expansionMap = _ref2.expansionMap,
          compactProof = _ref2.compactProof;

      try {
        // filter out matching proofs
        return Promise.resolve(Promise.all(proofSet.map(function (proof) {
          return purpose.match(proof, {
            document: document,
            documentLoader: documentLoader,
            expansionMap: expansionMap
          });
        }))).then(function (result) {
          var matches = proofSet.filter(function (_value, index) {
            return result[index];
          });
          return matches.length === 0 ? [] : Promise.resolve(Promise.all(matches.map(function (proof) {
            try {
              var _exit2 = false;
              return Promise.resolve(_forOf(suites, function (s) {
                return Promise.resolve(s.matchProof({
                  proof: proof,
                  document: document,
                  documentLoader: documentLoader,
                  expansionMap: expansionMap
                })).then(function (_s$matchProof) {
                  if (_s$matchProof) {
                    _exit2 = true;
                    return s.verifyProof({
                      proof: proof,
                      document: document,
                      purpose: purpose,
                      documentLoader: documentLoader,
                      expansionMap: expansionMap,
                      compactProof: compactProof
                    })["catch"](function (error) {
                      return {
                        verified: false,
                        error: error
                      };
                    });
                  }
                });
              }, function () {
                return _exit2;
              }));
            } catch (e) {
              return Promise.reject(e);
            }
          }))).then(function (_Promise$all) {
            return _Promise$all.map(function (r, i) {
              if (!r) {
                return null;
              }

              if (r.error) {
                _this._addToJSON(r.error);
              }

              return _extends({
                proof: matches[i]
              }, r);
            }).filter(function (r) {
              return r;
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    this._addToJSON = function (error) {
      Object.defineProperty(error, 'toJSON', {
        value: function value() {
          return serializeError.serializeError(this);
        },
        configurable: true,
        writable: true
      });
    };

    this.verify = function (document, _temp7) {
      var _ref3 = _temp7 === void 0 ? {} : _temp7,
          suite = _ref3.suite,
          purpose = _ref3.purpose,
          documentLoader = _ref3.documentLoader,
          expansionMap = _ref3.expansionMap,
          _ref3$compactProof = _ref3.compactProof,
          compactProof = _ref3$compactProof === void 0 ? true : _ref3$compactProof;

      try {
        if (!suite) {
          throw new TypeError('"options.suite" is required.');
        }

        if (!purpose) {
          throw new TypeError('"options.purpose" is required.');
        }

        var suites = Array.isArray(suite) ? suite : [suite];

        if (suites.length === 0) {
          throw new TypeError('At least one suite is required.');
        }

        var legacy = suites.some(function (s) {
          return s.legacy;
        });

        if (legacy) {
          throw new TypeError("Legacy suites are no longer supported.");
        }

        if (!documentLoader) {
          throw new TypeError('"options.documentLoader" is required.');
        }

        if (expansionMap !== false) {
          expansionMap = strictExpansionMap;
        }

        return Promise.resolve(_catch(function () {
          function _temp6() {
            // get proofs from document
            return Promise.resolve(_this2._getProofs({
              document: document,
              legacy: legacy,
              documentLoader: documentLoader,
              expansionMap: expansionMap,
              compactProof: compactProof
            })).then(function (_ref4) {
              var proofSet = _ref4.proofSet,
                  doc = _ref4.document;
              document = doc; // verify proofs

              return Promise.resolve(_this2._verify({
                document: document,
                suites: suites,
                proofSet: proofSet,
                purpose: purpose,
                documentLoader: documentLoader,
                expansionMap: expansionMap,
                compactProof: compactProof
              })).then(function (results) {
                if (results.length === 0) {
                  throw new Error('Could not verify any proofs; no proofs matched the required ' + 'suite and purpose.');
                } // combine results


                var verified = results.some(function (r) {
                  return r.verified;
                });

                if (!verified) {
                  var _ref5;

                  var errors = (_ref5 = []).concat.apply(_ref5, results.filter(function (r) {
                    return r.error;
                  }).map(function (r) {
                    return r.error;
                  }));

                  var result = {
                    verified: verified,
                    results: results
                  };

                  if (errors.length > 0) {
                    result.error = errors;
                  }

                  return result;
                }

                return {
                  verified: verified,
                  results: results
                };
              });
            });
          }

          var _temp5 = function () {
            if (typeof document === 'string') {
              // fetch document
              return Promise.resolve(documentLoader(document)).then(function (_documentLoader) {
                document = _documentLoader;
              });
            } else {
              // TODO: consider in-place editing to optimize when `compactProof`
              // is `false`
              // shallow copy to allow for removal of proof set prior to canonize
              document = _extends({}, document);
            }
          }();

          return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
        }, function (error) {
          _this2._addToJSON(error);

          return {
            verified: false,
            error: error
          };
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  var _proto = ProofSet.prototype;

  _proto.add = function add(document, _temp13) {
    var _ref6 = _temp13 === void 0 ? {
      compactProof: true
    } : _temp13,
        suite = _ref6.suite,
        purpose = _ref6.purpose,
        documentLoader = _ref6.documentLoader,
        expansionMap = _ref6.expansionMap,
        _ref6$compactProof = _ref6.compactProof,
        compactProof = _ref6$compactProof === void 0 ? true : _ref6$compactProof;

    try {
      var _temp14 = function _temp14() {
        function _temp10() {
          // save but exclude any existing proof(s)
          var proofProperty = suite.legacy ? 'signature' : 'proof'; //const existingProofs = input[proofProperty];

          delete input[proofProperty]; // create the new proof (suites MUST output a proof using the security-v2
          // `@context`)

          return Promise.resolve(suite.createProof({
            document: input,
            purpose: purpose,
            documentLoader: documentLoader,
            expansionMap: expansionMap,
            compactProof: compactProof
          })).then(function (proof) {
            var _temp8 = function () {
              if (compactProof) {
                // compact proof to match document's context
                var expandedProof;

                if (suite.legacy) {
                  var _expandedProof;

                  expandedProof = (_expandedProof = {}, _expandedProof[constants.SECURITY_SIGNATURE_URL] = proof, _expandedProof);
                } else {
                  var _expandedProof2;

                  expandedProof = (_expandedProof2 = {}, _expandedProof2[constants.SECURITY_PROOF_URL] = {
                    '@graph': proof
                  }, _expandedProof2);
                } // account for type-scoped `proof` definition by getting document types


                return Promise.resolve(getTypeInfo({
                  document: document,
                  documentLoader: documentLoader,
                  expansionMap: expansionMap
                })).then(function (_ref7) {
                  var types = _ref7.types,
                      alias = _ref7.alias;
                  expandedProof['@type'] = types;
                  var ctx = jsonld.getValues(document, '@context');
                  return Promise.resolve(jsonld.compact(expandedProof, ctx, {
                    documentLoader: documentLoader,
                    expansionMap: expansionMap,
                    compactToRelative: false
                  })).then(function (compactProof) {
                    delete compactProof[alias];
                    delete compactProof['@context']; // add proof to document

                    var key = Object.keys(compactProof)[0];
                    jsonld.addValue(document, key, compactProof[key]);
                  });
                });
              } else {
                // in-place restore any existing proofs

                /*if(existingProofs) {
                      document[proofProperty] = existingProofs;
                    }*/
                // add new proof
                delete proof['@context'];
                jsonld.addValue(document, proofProperty, proof);
              }
            }();

            return _temp8 && _temp8.then ? _temp8.then(function () {
              return document;
            }) : document;
          });
        }

        // preprocess document to prepare to remove existing proofs
        var input;

        var _temp9 = function () {
          if (compactProof) {
            // cannot assume security context terms, so do full compaction
            return Promise.resolve(jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {
              documentLoader: documentLoader,
              expansionMap: expansionMap,
              compactToRelative: false
            })).then(function (_jsonld$compact2) {
              input = _jsonld$compact2;
            });
          } else {
            // TODO: optimize to modify document in place to maximize optimization
            // shallow copy document to allow removal of existing proofs
            input = _extends({}, document);
          }
        }();

        return _temp9 && _temp9.then ? _temp9.then(_temp10) : _temp10(_temp9);
      };

      if (!suite) {
        throw new TypeError('"options.suite" is required.');
      }

      if (!documentLoader) {
        throw new TypeError('"options.documentLoader" is required.');
      }

      if (!purpose) {
        throw new TypeError('"options.purpose" is required.');
      }

      if (suite.legacy) {
        throw new TypeError("Legacy suites are no longer supported.");
      }

      if (expansionMap !== false) {
        expansionMap = strictExpansionMap;
      }

      var _temp15 = function () {
        if (typeof document === 'string') {
          // fetch document
          return Promise.resolve(documentLoader(document)).then(function (_documentLoader2) {
            document = _documentLoader2;
          });
        }
      }();

      return Promise.resolve(_temp15 && _temp15.then ? _temp15.then(_temp14) : _temp14(_temp15));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ProofSet;
}();

var sign = function sign(document, _temp) {
  var _ref = _temp === void 0 ? {
    compactProof: true
  } : _temp,
      suite = _ref.suite,
      purpose = _ref.purpose,
      documentLoader = _ref.documentLoader,
      expansionMap = _ref.expansionMap,
      compactProof = _ref.compactProof;

  try {
    return Promise.resolve(_catch(function () {
      return Promise.resolve(new ProofSet().add(document, {
        suite: suite,
        purpose: purpose,
        documentLoader: documentLoader,
        expansionMap: expansionMap,
        compactProof: compactProof
      }));
    }, function (e) {
      if (!documentLoader && e.name === 'jsonld.InvalidUrl') {
        var url = e.details.url;
        var err = new Error("A URL \"" + url + "\" could not be fetched;" + "you need to pass \"documentLoader\" or resolve the URL before calling \"sign\".");
        err.cause = e;
        throw err;
      }

      throw e;
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var VerificationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(VerificationError, _Error);

  function VerificationError(errors) {
    var _this;

    _this = _Error.call(this, 'Verification error(s).') || this;
    _this.name = 'VerificationError';
    _this.errors = [].concat(errors);
    return _this;
  }

  return VerificationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var verify = function verify(document, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      suite = _ref.suite,
      purpose = _ref.purpose,
      documentLoader = _ref.documentLoader,
      expansionMap = _ref.expansionMap,
      compactProof = _ref.compactProof;

  try {
    return Promise.resolve(new ProofSet().verify(document, {
      suite: suite,
      purpose: purpose,
      documentLoader: documentLoader,
      expansionMap: expansionMap,
      compactProof: compactProof
    })).then(function (result) {
      var error = result.error;

      if (error) {
        if (!documentLoader && error.name === 'jsonld.InvalidUrl') {
          var url = error.details.url;
          var urlError = new Error("A URL \"" + url + "\" could not be fetched; you need to pass " + '"documentLoader" or resolve the URL before calling "verify".');
          result.error = new VerificationError(urlError);
        } else {
          result.error = new VerificationError(error);
        }
      }

      return result;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

exports.sign = sign;
exports.verify = verify;
//# sourceMappingURL=linked-data-proof.cjs.development.js.map
